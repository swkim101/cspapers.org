When a dirty victim page is selected for replacement upon page miss, the buffer manager has to first flush the dirty victim to the storage before reading the missing page. This conventional read-after-write (RAW) protocol, while working well on hard disks, causes the problem of read stall on flash storage with asymmetric read-write speed and parallelism; because of the resource conflict for a buffer frame between write and read operations, a page-missing process has to wait for the slow write to complete to secure a clean frame for the missing page. This strict write-then-read serialization under-utilizes CPU and storage, worsening transaction throughput and latency. To avoid the read stall problem on flash storage, this paper proposes write-after-read (WAR) protocol as a new I/O architecture between buffer manager and flash storage. In WAR, foreground processes make victim frames clean instantly by temporarily copying dirty pages at LRU tail into a separate DRAM space and read their missing pages into the cleaned frames with no stall. The dirty pages will be written to the storage asynchronously. By resolving resource conflict and thus avoiding read stalls, the database engine can issue more I/Os in parallel and better utilize CPU as well as storage, improving throughput and latency. We prototype WAR in two database storage engines, MySQL/InnoDB and Zero. Our comprehensive experimental results show that WAR improves transaction throughput by up to 2.9x compared to RAW.