Designers of modern reader-writer locks confront a difficult trade-off related to reader scalability. Locks that have a compact memory representation for active readers will typically  suffer under high intensity read-dominated workloads when the "reader indicator" state is updated frequently by a diverse set of threads, causing cache invalidation and coherence traffic.   Other designs use distributed reader indicators, one per NUMA node, per core or even per thread. This improves reader-reader scalability, but also increases the size of each lock  instance and creates overhead for writers.  We propose a simple transformation, BRAVO, that augments any existing reader-writer lock, adding  just two integer fields to the lock instance.  Readers make their presence known to writers by hashing  their thread's identity with the lock address, forming an index into a visible readers table and installing the lock address into the table.
All locks and threads in an address space can share the same readers table.   Crucially, readers of the same lock tend to write to different locations in the table, reducing coherence traffic. Therefore, BRAVO can augment a simple compact lock to provide scalable concurrent reading, but with only modest and constant increase in memory footprint.We implemented BRAVO in user-space, as well as integrated it with the Linux kernel reader-writer semaphore (rwsem). Our evaluation with numerous benchmarks and real applications, both in user and kernel-space, demonstrate that BRAVO improves performance and scalability of underlying locks  in read-heavy workloads while introducing virtually no overhead, including in workloads in which writes are frequent.