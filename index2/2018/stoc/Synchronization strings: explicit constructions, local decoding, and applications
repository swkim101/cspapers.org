This paper gives new results for synchronization strings, a powerful combinatorial object introduced by [Haeupler, Shahrasbi; STOC’17] that allows to efficiently deal with insertions and deletions in various communication problems: - We give a deterministic, linear time synchronization string construction, improving over an O(n5) time randomized construction. Independently of this work, a deterministic O(n log2 logn) time construction was proposed by Cheng, Li, and Wu. - We give a deterministic construction of an infinite synchronization string which outputs the first n symbols in O(n) time. Previously it was not known whether such a string was computable. - Both synchronization string constructions are highly explicit, i.e., the ith symbol can be deterministically computed in O(logi) time. - This paper also introduces a generalized notion we call long-distance synchronization strings. Such strings allow for local and very fast decoding. In particular only O(log3 n) time and access to logarithmically many symbols is required to decode any index. The paper also provides several applications for these improved synchronization strings: - For any δ < 1 and є > 0 we provide an insdel error correcting block code with rate 1 − δ − є which can correct any δ/3 fraction of insertion and deletion errors in O(n log3 n) time. This near linear computational efficiency is surprising given that we do not even know how to compute the (edit) distance between the decoding input and output in sub-quadratic time. - We show that local decodability implies that error correcting codes constructed with long-distance synchronization strings can not only efficiently recover from δ fraction of insdel errors but, similar to [Schulman, Zuckerman; TransInf’99], also from any O(δ / logn) fraction of block transpositions and block replications. These block corruptions allow arbitrarily long substrings to be swapped or replicated anywhere. - We show that highly explicitness and local decoding allow for infinite channel simulations with exponentially smaller memory and decoding time requirements. These simulations can then be used to give the first near linear time interactive coding scheme for insdel errors, similar to the result of [Brakerski, Naor; SODA’13] for Hamming errors.