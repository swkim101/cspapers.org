Sorting is one of the fundamental algorithmic problems in theoretical computer science. It has a natural generalization, introduced by Fredman in 1976, called sorting under partial information. The input consists of: –a ground set <tex>$X$</tex> of size <tex>$n$</tex>, –a partial oracle <tex>$O_{F}$</tex> (where partial oracle queries for any <tex>$(x_{i},x_{j})$</tex> output whether <tex>$x_{i}\prec _{P}x_{j}$</tex>, for some partial order <tex>$P$</tex>), –a linear oracle <tex>$O_{L}$</tex> (where linear oracle queries for any <tex>$(x_{i},x_{j})$</tex> output whether <tex>$x_{i} < _{L}x_{j}$</tex> and the order <tex>$L$</tex> extends <tex>$P$</tex>) The goal is to recover the linear order <tex>$L$</tex> on <tex>$X$</tex> using the fewest number of linear oracle queries. In this problem, we measure algorithmic complexity through three metrics: the number of linear oracle queries to <tex>$O_{L}$</tex>, the number of partial oracle queries to <tex>$O_{P}$</tex>, and the time spent (the number of algorithmic instructions required to identify for which pairs <tex>$(x_{i},x_{j})$</tex> a partial or linear oracle query is performed). Let <tex>$e(P)$</tex> denote the number of linear extensions of <tex>$P$</tex>. Any algorithm requires worst-case <tex>$\log_{2}e(P)$</tex> linear oracle queries to recover the linear order on <tex>$X$</tex>. In 1984, Kahn and Saks presented the first algorithm that uses <tex>$\Theta(\log e(P))$</tex> linear oracle queries (using <tex>$O(n^{2})$</tex> partial oracle queries and exponential time). Since then, both the general problem and restricted variants have been consistently studied. The state-of-the-art for the general problem is by Cardinal, Fiorini, Joret, Jungers and Munro who at STOC'10 manage to separate the linear and partial oracle queries into a preprocessing and query phase. They can preprocess <tex>$P$</tex> using <tex>$O(n^{2})$</tex> partial oracle queries and <tex>$O(n^{2.5})$</tex> time. Then, given <tex>$O_{L}$</tex>, they uncover the linear order on <tex>$X$</tex> in <tex>$\Theta(\log e(P)$</tex> linear oracle queries and <tex>$O(n+\log e(P))$</tex> time - which is worst-case optimal in the number of linear oracle queries but not in the time spent. We present the first algorithm that uses a subquadratic number of partial oracle queries. For any constant <tex>$c\geq 1$</tex>, our algorithm can preprocess <tex>$O_{F}$</tex> using O <tex>$O(n^{1+\frac{1}{c}})$</tex> partial oracle queries and time. Given <tex>${OL}$</tex>, we uncover the linear order on <tex>$X$</tex> using <tex>$\Theta(c\log e(P))$</tex> linear oracle queries and time, which is worst-case optimal. We show a matching lower bound for the prepossessing also, as we show that there exist positive constants <tex>$((y,\beta)$</tex> where for any constant <tex>$c\geq 3$</tex>, any algorithm that uses at most <tex>$\alpha\cdot n^{1+\frac{1}{c}}$</tex> partial oracle queries must use worst-case at least <tex>$\beta\cdot c\log e(P)$</tex> linear oracle queries. Thus, we solve the problem of sorting under partial information through an algorithm that is asymptotically tight across all three metrics.