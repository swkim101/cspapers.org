Oblivious RAM (ORAM) allows a client to securely outsource memory storage to an untrusted server. It has been shown that no ORAM can simultaneously achieve small bandwidth blow-up, small client storage, and a single roundtrip of latency. We consider a weakening of the RAM model, which we call the Single Access Machine (SAM) model. In the SAM model, each memory slot can be written to at most once and read from at most once. We adapt existing tree-based ORAM to obtain an oblivious SAM (OSAM) that has ğ‘‚ ( log ğ‘› ) bandwidth blow-up (which we show is optimal), small client storage, and a single roundtrip. OSAM unlocks improvements to oblivious data structures/algorithms. For instance, we achieve oblivious unbalanced binary trees (e.g. tries, splay trees). By leveraging splay trees, we obtain a notion of caching ORAM , where an access in the worst case incurs amortized ğ‘‚ ( log 2 ğ‘› ) bandwidth blow-up and ğ‘‚ ( log ğ‘› ) roundtrips, but in many common cases (e.g. sequential scans) incurs only amortized ğ‘‚ ( log ğ‘› ) bandwidth blow-up and ğ‘‚ ( 1 ) roundtrips. We also give new oblivious graph algorithms, including computing minimum spanning trees and single source shortest paths, in which the OSAM client reads/writes ğ‘‚ (| ğ¸ | Â· log | ğ¸ |) words using ğ‘‚ (| ğ¸ |) roundtrips, where | ğ¸ | is the number of edges. This improves over prior custom solutions by a log factor. At a higher level, OSAM provides a general model for oblivious computation. We construct a programming interface around OSAM that supports arbitrary pointer-manipulating programs such that dereferencing a pointer to an object incurs ğ‘‚ ( log ğ‘‘ log ğ‘› ) bandwidth blowup and ğ‘‚ ( log ğ‘‘ ) roundtrips, where ğ‘‘ is the number of pointers to that object. This new interface captures a wide variety of data structures and algorithms (e.g.,