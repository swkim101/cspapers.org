The K shortest path (KSP) algorithm, which finds the top $K$ shortest simple paths from a source to a target vertex, has a wide range of real-world applications, e.g., routing, vulnerability detection, and biology analysis. While the top $K$ shortest simple paths offer in-valuable insights, computing them is time-consuming. For example, on a Twitter graph (61.6M vertices and 1.5B edges), the best parallel method needs about 20 minutes to get 128 shortest paths between two vertices. A key observation we made is existing works search $K$ shortest paths from the original graph, while top $K$ shortest paths only cover a meager portion of the original graph, e.g., less than 0.001 % on a Twitter graph for K = 128. This paper introduces Peek, a pruning-centric approach for KSP computation. First, Peek applies $K$ upper bound pruning to prune the vertices and edges that will not appear in any of the $K$ shortest paths. Second, Peek adaptively compacts the graph that, not only removes the deleted vertices or edges but also efficiently computes the downstream task. Furthermore, we design efficient techniques to parallelize and distribute Peek. We compare Peek with five algorithms on various graphs. For parallel computation with 32 threads, Peek achieves 5.1x and 28.8x speedup over the state-of-the-art for K = 8, 128, respectively. More importantly, when $K$ increases, the runtime of Peek is barely affected. In particular, when $K$ increases from 2 to 128 (64x), the runtime of Peek only increases 1.1x, while the state-of-the-art method increases 10.3x.