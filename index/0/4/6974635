Memory tracing (executing additional code for every memory access of a program) is a powerful technique with many applications, e.g., debugging, taint checking, or tracking dataflow. Current approaches are limited: software-only memory tracing incurs high performance overhead (e.g., for Libdft up to 10×) because every single memory access of the application is checked by additional code that is not part of the original application and hardware is limited to a small set of watched locations. 
 
This paper introduces memTrace, a lightweight memory tracing technique that builds on dynamic on-the-fly cross-ISA binary translation of 32-bit code to 64-bit code. Our software-only approach enables memory tracing for unmodified, binary-only ×86 applications using the ×64 extension that is available in current CPUs; no OS extensions or special hardware is required. The additional registers in ×64 and the wider memory addressing enable a low-overhead tracing infrastructure that is protected from the application code (i.e., uses disjunct registers and memory regions). MemTrace handles multi-threaded applications. Two case studies discuss a framework for unlimited read and write watchpoints and an allocation-based memory checker similar in functionality to memgrind. 
 
The performance evaluation of memTrace shows that the time overhead is between 1.3× and 3.1× for the SPEC CPU2006 benchmarks, with a geometric mean of 1.97×.