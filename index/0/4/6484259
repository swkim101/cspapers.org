A DSL (c.f. [1]) provides constructs that correspond to key concepts in a given problem domain. A well-designed DSL can allow domain experts to write more maintainable and safer applications faster than would be possible in a general-purpose language (c.f. [4]). There are two traditional approaches taken to implementing DSLs: compilers and interpreters. The first one is to compile DSLs directly into machine-level code, or to lowlevel languages such as C. While this approach results in fast implementations, it is not always practical. Writing compilers often requires expertise in compiler technology, and implementing the compilers takes a long time. Extending the DSL can be difficult because of the complexity of such compilers. An alternative approach is to use an interpreter to implement a DSL. Interpreters are much easier to