lecting the k-th smallest element in a binary heap of size n >> k. The result matches the information theoretic lower bound, settles an open problem, and contradicts a recently reported lower bound. 1. I n t r o d u c t i o n A problem of importance in the design of a number of algorithms is that of finding the k-th smallest element in a set of unordered elements [BFPRT], [SPP], [B J]. A more general version of this problem, and one with additional applications, allows the set of elements to satisfy a relation encoded in some partial order IF J2], or forbids certain total orders for the set [FJ1], [CSSS]. For example, algorithms with optimal running times have been given in IF J2] for selecting the k-th smallest element in a collection of sorted matrices (matrices whose entries in any row or column are in sorted order). For the above version of this problem, the upper bounds match information theory lower bounds IF J2]. A natural question to ask is whether the complexity of finding the k-th smallest element in a set of elements organized in any given partial order coincides with the information theory lower bound. Thus we wish to know if the information in certain partial orders can be extracted *This research was supported in part by the National Science Foundation under grant CCR-86202271 and by the Office of Naval Research under contract NO0014-86-K-0689. Permission to copy without fee all or part of this material is granted provided that the copies are not made or distributed for direct commercial advantage, the ACM copyright notice and the title of the publication and its date appear, and notice is given that copying is by permission of the Association for Computing Machinery. To copy otherwise, or to republish, requires a fee and/or specific permission. efficiently. In addition, we wish to know how to coordinate the acquisition of information from partial orders. We focus these questions by considering a partial order for a binary heap, i.e., a partial order on items xi, i = 1 , 2 , . . , n , where xi > xti/2 j for i = 2 , . . . , n . We shall concentrate on examples in which k is much much smaller than n, so that for all intents and purposes the heap can be viewed as infinite. The problem is tricky because the partial order associated with a heap is rather "bushy", and for k > 1 the k-th smallest element can be in any one of 2 k 2 positions in the heap. In their investigations culminating in IF J2], this author and Donald Johnson observed that there was a sizable gap between the straightforward lower bound of f2(k) and a simple upper bound of O(k log k).l The problem of narrowing this gap by raising the lower bound was stated as an open problem in [AK]. Recently, a lower bound of f~(k log k) has been claimed in [WN], but the arguments make unwarranted assumptions about how such a selection algorithm must work. The straightforward lower bound is based on information theory. The number of binary trees with k nodes is 1 ~ ( 2 : ) , which is greater than 4k/(kVt '~) . (See pp. 388-389 of [K]). It follows that the height of any decision tree to select the k-th element in an infinite heap is at least 2k 3 log k 1. The straightforward upper bound is achieved by creating an auxiliary heap. The auxiliary heap is initialized as containing a single value equal to that of element xl . Then the following is done for k steps: The minimum is extracted from the auxiliary heap, and two values are inserted into it. The values inserted are equal to 1 All logarithms are to the base 2. © 1990 ACM 089791-361-2/90/0005/0026 $1.50 26 elements z2i and x2i+l, where xi equals the value just extracted from the auxiliary heap. Clearly, this takes O(klogk) time. We note that the inverse problem of finding the rank of a given element x in a heap is easy. Just perform an inorder traversal of the subtree induced by all values no greater than z. This clearly takes O(k) time, where k is the rank of x in the heap. In this paper we present an algorithm to select the kth smallest element in a heap that is optimal to within a constant factor. We achieve a time of O(k) by using the following ideas. First, we organize appropriate elements into groups, called clans, and handle a representative of each clan in a heap. Second, we form clans on a number of different levels, forming larger clans recursively from smaller clans. We use heaps on each of the resulting O(log* k) levels. 2 Third, we redefine clans, choosing a nonobvious rule for inclusion of elements into a clan. Finally we form each clan incrementally, using a number of different clan sizes on any level, and insert the new representative of an enlarged clan back into a heap. In section 2 we show how to group the elements together into a relatively simple scheme that realizes a time of O( k log log k ). We then apply this approach recursively to yield an O(k 3 ]°g° k)-time algorithm. In section 3 we elaborate on the additional ideas that bring the time down to O(k). For simplicity in the exposition, we assume that all elements in the heap are distinct. 2. G r o u p i n g e l e m e n t s i n t o c lans In this section we show how to group elements into subsets in order to reduce the overhead of extracting a minimum in a heap. First, we show how to use a second auxiliary heap to achieve a time of O(k log log k). Then we generalize the problem and apply a recursive scheme to achieve a time of O(k 3 I°g" k). Our first idea is to group elements together into subsets of equal size, called clans. We shall choose the clan size initially to be [log k]. The largest element in each clan will be called the representative of the clan. The representatives of the clans are then inserted into and extracted from the auxiliary heap. If the clans are formed appropriately, then after [k/[logkJ] extra ctmin operations, the last element extracted will have rank 2The funct ion log* k is the i te ra ted logar i thm of k, defined by log* 1 = log* 2 = 1 and log* k = 1 + log* [ logk] for k > 2. between k and 2k in the original heap. It is then easy to identify all elements in the original heap smaller than this element and select directly in this set, using the algorithm from [BFPRT]. Note that since there are only [k/[logkJ] exlraclmin operations in the auxiliary heap, the time to perform these extractmin operations is O(k) and thus is no longer a bottleneck in the algorithm. The crucial issue is how to group elements into clans. A logical choice is to group the [log kJ smallest elements together to form a first clan C1. A second clan C2 can be formed by grouping the next [log k] smallest elements together. To describe the formation of the remaining clans we introduce some terminology. Assume that the clans are formed one at a time. When a clan C i is formed, those elements that are not in Cj, but are children of elements in the original heap that are in Cj, are called the offspring os(Cj) of clan Cj. For i > 2, the clan Ci can be formed in one of two ways. First, consider an extractmin operation, which extracts the representative of some clan, say Cj. A clan Ci is formed by grouping the [log kJ smallest elements from the subheaps rooted at the offspring os(Cj) of Cj. The second way to form a clan is motivated by the following. Since there may be some offspring of clan Cj not included in Ci, and since clan Cj no longer has a representative in the auxiliary heap, we assign them as a responsibility to the new clan Ci, and call them the poor relations pr(Ci) of clan Ci. Thus if there is a nonempty set of poor relations pr(Cj) of clan Cj, then when the representative of clan Cj is extracted from the auxiliary heap, a second clan Ci+l is created, consisting of the [log kJ smallest elements from the subheaps of the original heap rooted at the poor relations of the Cj. Thus for each clan Cj, j > 1, there are two sets associated with it, the offspring os(Cj) and the poor relations pr(Cj). When the representative of Cj is extracted from the auxiliary heap, clans must be formed starting with each of these two sets. As an example, consider the heap in Figure 1. We can imagine that the heap is actually much bigger, and only the first five levels are shown in the figure. Suppose k = 8. Then each clan will be of size 3. The first four clans created have been circled. C1 = {1,2,3}, os(C1) = {7,10,12,4} and pr(Cx) = 0. The repre-