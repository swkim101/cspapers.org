Understanding how a sensor network system works requires runningthe system, extracting log files, and manually interpreting systemmetrics. When interpreting system metrics, we often try tocorrelate behavior over multiple modalities. For example, if a nodeis exhibiting strange behaviors, the cause may be due to weakbattery, geographically bad placement, collision, interference,sensor failure, algorithmic faults, or a combination of the above.This approach of interpreting metrics is adequate for closedsystems such as the ones run in simulations, with limited duration.However, for complex sensor network systems that have already beendeployed for weeks or even months in the fields, this approach isdifficult, laborious, and error-prone. Thus, a suite of tools tohelp analyze complex sensor network system is desirable. We haveimplemented Deployment Analysis System (DAS), a centralized datamining suite designed to better understand sensor networks. Itsupports visualization and deployment-related queries that allowthe user to inspect historical system metrics, environmental data,geographical placements, and system status.
The DAS user interface displays real-time and historicalinformation in an easy-to-use and intuitive format. The topologicalmap feature allows users to have both a historical and immediateview of the system status with metrics such as routing table,neighbor tables, and the number of neighbors heard, among others.The historical map helps users view and narrow down past points offailure and for refinements on future deployments. For example, ithelps pinpoint bottlenecks in the network or bad connectivity dueto environmental conditions, resulting in unexpected low throughputat the sink. In addition to the static map, DAS also provideshistorical routing replay animation. This feature allowsprogrammers to validate and to make assessments to routingalgorithms. For example, using the replay animation, a user candetermine route stability, and overall efficiency of moteplacements and route choices. In one instance, we used DAS toinspect one of the environmental deployments in James Reserve atSan Jacinto and observed that in many cases, motes that had highelevation were frequently used as a next-hop neighbor even thoughmany were much farther away from the final destination. We alsoobserved unexpected routing dependencies such that when one motebecame inoperative, the communication for a cluster of other moteswere cut-off, even though their proximities to each other shouldhave provided redundanc.
In addition to the topological map, DAS generates differentcharts that include single metric multiple nodes graph, multiplemetrics single node graph, and link quality graph. Using thesegraphs users can easily identify spatial-temporal correlations andevents over system metrics and environmental data. For instance weused DAS to easily generate two graphs in two different instances(using a total of less than 4 mouse clicks) which show that thebattery voltage of nodes tends to degrade simultaneously. In bothcases the entire sensor network was broken within 5 days. We usedthis observation to apply to later deployments-- if the batterylevel of a few motes starts to degrade, we should change batteriesquickly as a preventive measure from total system failure.Likewise, we used DAS to generate graphs which shows thetemperature affects the battery level directly, and in some casesincrease the frequency of route-flapping. This revelation opens upthe possibility of fine tuning routing and link estimationalgorithms based on past data, and even predicted trends.
The back-end of DAS is completely detached from its CGI basedfront-end. It stores environmental data with internal systemmetrics in a traditional database, accessible using inputextensions and output extensions. Currently DAS has a pluggableinput extension to Sympathy system metrics and general sensor datafrom ESS2 applications, and the infrastructure allows other datatypes to be easily added or changed to accommodate for other sensornetworks. Some of the output extensions that have been implementedinclude the graphical user interface, status display, andevent-trigger notification facilities. Since the framework usesopen tools it can be easily interfaced with other systems based onC, Java, GNU Plot, and Visual Studio tools.