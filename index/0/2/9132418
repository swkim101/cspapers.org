develops the hardware and software for This experience report describes the experien ces we have had at BNR building large Object Oriented frameworks to support telephony applications. It focuses on a few key areas: l How to determine what functionality a framework should provide. l How to validate an architecture before it is built through “architectural prototyping” and “continuous integration”. l Other benefits of using Object Technology on large projects. This report was based on four experience most of NT’s products, including the central office telephone exchange known as DMS100. Telephone exchanges, also known as “switches”, are very large specialized embedded real-time systems. The DMS:lOOF family of systems comprises eight products ranging from Local Access telephone switch to Signal Transfer Point and consists of over 25 (twenty five) million lines of source code written in Protel, an objectbased Pascal-like language. About the Generic Service Framework (GSF) Project reports submitted to OOPSLA-94; the other authors were: Richard Wardle. Neil DMS-100 is a highly featured Local Access Thomson, Brent Sprinkle, Sky Matthews, telephone switch delivered to North Malgosia Plucinska, Todd Hansen, Dennis American and Global markets. Each market Leung, Paul Winterhalder, Marnie has specific requirements for a multitude Beaubien, Ron Hough and Bill Shanahan. of services (e.g. Call Waiting, 3-Way Background Calling). These requirements vary from market to market requiring extensive About BNR and Northern Telecom customization or parallel implementations. The GSF project was launched to establish Northern Telecom (NT) is a leading leadership in switching software archisupplier of digital telecommunication tecture to enable responsiveness to our equipment. BNR is its Research and customers’ requirements in global markets. Development subsidiary. In this role, BNR The decision was made to design the call processing software using Object Oriented technology (OOT) to enable faster delivery of the many variations of services to global markets. We plan to have the bulk of the developers of DMS-100 transitioned to OOT by the end of 1995; about one third have al14 Portland, OR October 23-27,1994 ready made the transition. Discovering Framework Requirements The goal of the GSF project is to build an object-oriented framework for call processing applications enabling faster delivery of the many variations of services to global markets. The project involves a large number of teams developing generic framework(s) as well as developing a number of applications. Historically the call processing software has been developed one application at a time, and the software reworked to meet the needs of each particular application as it came along. The primary drive for the GSF project was to create a flexible software architecture capable of meeting current and future requirements of our customers. As the project was forming, a number of application teams expressed a strong interest in becoming the first customers of the framework. In the spirit of our decision to use an object-oriented design process, we asked for requirements to be delivered to us in the form of Use Cases. Our initial pass resulted in the creation of several hundred Use Cases, in part because groups new to OOT were attempting to do all their Use Case modelling before building Domain or Analysis models. Problems encountered The task of requirements capture and analysis turned out to be difficult for the following reasons: Requirements were captured in a variety of formats and levels of detail some were extremely detailed, others too abstract to be useful. There was a lot repetition of the same capabilities described by different applications. Also, in the telecommunications domain, requirements are often derived from external specifications which can be inconsistent and ambiguous. Many of the requirements were provided to us in terms of design solutions based on the previous software implementation. The sheer number of Use Cases received made the task of analysis impossible given limited time and resources. Most of the requirements were written without a common vocabulary. This makes it difficult to communicate concepts between individuals and groups on a large project. For example, the same concept may be referred to by different names even within the same requirement specification. Information sharing and discovery of system wide commonality was extremely difficult due the lack of consistency of the requirement specifications. It quickly became apparent that the way we were doing requirements capture was not productive, and that our initial process would not work. A new approach had to be put in place to better focus our efforts . Strategy for success The strategy we finally adopted for requirements gathering and analysis included the following steps: An initial object model was developed before the requirements were examined in great detail. The model was verified by testing it against known high-level requirements and applying it in various scenarios. This was made possible by drawing on extensive experience of telecommunications domain experts. Addendum to the Proceedings OOPSLA ‘94 15 The scope of the initial requirements gathering was limited to two applications. This prevent the “analysis paralysis” that can be caused by too much information. Two detailed scenarios were developed jointly with application primes therefore establishing a template for future scenarios. This ensured a uniform level of understanding between the framework developers and application experts. Based on the provided scenarios, the required system capabilities were derived and mapped onto the framework components as a set of framework capabilities. The request to provide the specified framework capabilities was made to the owners of the particular component. The owners would determine how the requested capability was going to be provided internally by their design. The object models were refined to show the newly added framework capabilities. Validating an Architecture through Prototyping On a large project (hundreds of developers), the discovery of architectural problems after coding can result in large amounts of rework. Just finding and informing all the affected developers can take many weeks. This is probably one of the key causes of the “software crisis.” It is crucial that the software integration occurs smoothly; this requires advance preparation during the architecture and design phases of the project.