It is generally agreed that to meet these objectives and achieve integration an IPSE should be built round a kernel or infrastructure of common services.
Coherence is then achieved if the infrastructure provides services to tools which relieve the toolwriter of the need to code, for example, user interface handling. Not only does this aid uniformity, but of course it also offers economic leverage.
Control of the environment resides in the kernel and it is not possible for tools to ignore the controls and prejudice the integrity of the project data.
Sharing is achieved because the project data and its structure reside in the database which is under the control of the kernel.
Early efforts to build such an IPSE were based on the STONEMAN model, where the kernel was the KAPSE. The crucial interface in this architecture is the KAPSE interface, which offers services to all tools. We did not sufficiently realise, however, that there is a major economic problem in designing a new interface from scratch. All tools which are to be used in an environment must, by definition, conform to this interface definition. This means that all the tools have to be specially written to use the new interface, and it became apparent that no single organisation could or should expect to provide a complete new tool kit in this way. Rather one wants an open market in software tools, in the same way that it is hoped Ada will lead to an open market in software components. The more recent history of IPSE efforts, therefore, has been an attempt to resolve the conflict between the desire for integration and the need for environments to accept a wide range of tools from various sources.
 Perhaps the most ambitious project taking this approach is ASPECT, a project within the UK Alvey programme, which is currently delivering prototypes for evaluation. ASPECT aims to provide a highly functional Open Tool Interface covering coherence, control and sharing. It does this by treating the Open Tool Interface as a special case of an adaptable interface which provides user-defined views of the underlying kernel. This approach depends heavily on the notions of views developed in the relational database world.