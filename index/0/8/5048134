We study the problem of scheduling parallel machines online, allowing preemptions while disallowing migration of jobs that have been scheduled on one machine to another. For a given job, we measure the quality of service provided by an algorithm by the stretch of the job, defined as the ratio of the amount of t ime the job spends in the system (also known as the response iime) to its processing time. For a sequence of jobs, we measure the performance of an algori thm by the average stretch achieved over all the jobs. The scheduling goal is to minimize the average stretch. This problem is of relevance in many applications, e.g., wireless data servers and distributed server systems in wired networks. We prove an O(1) competitive ratio for this problem. The algorithm for which we prove this result is the one proposed in [2] that has (tight) logarithmic competitive ratio for minimizing the average response time. Thus the algorithm in [2] simultaneously performs well for average response time as well as average stretch. We prove the O(1) competitive ratio agMnst an adversary who not only knows the entire input ahead of time, but is also allowed to migrate jobs. Thus our result shows that migration is not necessary to be competitive for minimizing average stretch; in contrast, we prove that preemption is essential, even if randomization is allowed. We also establish a constant-factor lower bound on the competitive ratio of any online algorithm that minimizes average stretch without migration. ~ s c h e UniversitKt Graz, Inst i tut fftr Mathematik B; luca~opt.math.tu-graz.ac.at and Dipaxtimento di Informatica Sistemistica, Universitk di Roma "La Sapienza", via Salaria 113, 00198-Roma, Italia. t Dipart imento di Informatica Sistemistica, Universith dl Roma "La Sapienza", via Saiaria 113, 00198-Roma, Italia. This work was partly supported by EU ESPRIT Long term Research Project ALCOM-IT under contract n. 20244. F_~-Mail: leon~dis.uniromal. i t . tAT&T Labs Research. E-Maih muthu@research.att.com. 1 I n t r o d u c t i o n There is increasing wireless support for data networks because of the growth in mobile clients (e.g., palm tops) as well as "data-centric" applications (e.g., traffic information systems, s tock/sports tickers, wireless internet access etc.). Data servers in wireless networks receive continuous stream of requests for documents from users, requests varying over several orders of magnitude in size. They feed data to the users over multiple channels 1. Scheduling the delivery of da ta over multiple channels is an instance of the problem we study here. A similar scheduling problem arises in wired data networks" as well. In order to increase the capacity of servers in wired networks, systems use distributed servers [17]. Requests for documents arrive at a central dispatcher which must schedule them at one of the multiple servers for delivery. Scheduling data delivery as in the two motivating applications above is the classical multiprocessor scheduling problem where each channel or server may be thought of as a machine, and each request for a document as a job. Data must be delivered in a responsive manner this is typically abstracted as the problem of scheduling jobs on the multiprocessor system to optimize some metric. There are two issues to clarify further, namely, the model for scheduling jobs and metric to be optimized. In our model, jobs may be preempted, that is, a job that is being processed may be interrupted and resumed later after processing other jobs in the interim. Preemption improves the system performance, however there is a penalty. In multiprocessor computer systems, it requires a context switching at a processor but this cost is reasonably small. 2 In the case of distributed server systems we described, interrupting the delivery of a large file to service small ones is reasonable if it improves system performance because the end users see T--Depending on the wireless technology, "channels" has different meanings. In Frequency Division Multiple Access (FDMA), it is frequency. In Time Division Multiple Access (TDMA), it is time slots. In Code Division Multiple Access (CDMA), it is codes. See [1, 12] and references therein for details. 2Thls in particular holds in systems that support threads [9, 18, 25, 26].