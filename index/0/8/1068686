We discuss schemes for efficiently implementing the primitives of two commonly-used message-passing packages – PVM and TCGMSG for cache-coherent cache-only memory access (CC-COMA ) machines, using the attraction memory on these machines to advantage. We fist describe a generic interface for message-passing and buffering, and map the specific calls of these two packages on to this generic interface. We derive analytical results about the achievable bandwidth for message-passing via the shared memory on CC-COMA machines, pointing out the problems that arise due to the use of such architecture. We then show how these problems can be tackled by latency-biding techniques available on most CC-COMA machines. We report the performance of our implementation of each of the two libraries. Finally, we suggest some new features to the system software on multiprocessors which might support such packages more efficiently, and point out some drawbacks in the interfaces of the packages which hinder their efficient implementation on multiprocessors. The K SR supercomput er is used as a running example throughout the paper. ● Authors’ current addresses Kaush]k Ghosh, Sdicon Graphics Inc , Mountain View, CA 94043, Stephen R Brelt, Dragon Systems Inc., Newton, MA 02160 Thx+ work was performed under the supervision of Stephen Brelt whale Kaushik Ghosh was on an mternshlp at Kendall Square Research (July September ’93) Denms Marsa Implemented an earher version of TCGMSG on the KSR1 o Permission to make digitallhard copies of all or part of this material for peraoml or classroom use ia granted without fee provided that the copies are not made or distributed for profit or commercial advantage, the. copyright notice, the title of the publication and its date appear, and notice is given tha} cop yrigbt is by permission of ~G.ACM, IflG. To Gopy otherwise, to repubbsb, to post on servers or to redwtnbute to ksta, requms specific permission and/or fee. ICS’96, Philadelphia, PA, USA @1996 ACM ()+9791+03.7/96/()5. .$3.50 1 Motivation and Contributions In recent years, distributed computing has been widely used for high throughput at low cost. Message-passing is a low level of communication software on a network of computers. While powerful high-level abstractions like Distributed Shared Memory can be built up over a layer of message passing software, raw, low-level message-passing usually produces the best performance. Several message-passing libraries are available today: CPS [4], Linda [1], TCGMSG [6] and PVM [11], to name a few. Most of these libraries are complete paraJ.lelprogramming environments, rather than mere low-level communication software. There is now an increasing number of application programs that have been parallelized using these “standard” message-passing interfaces. Further, the comparative overheads of message-passing vs. shared memory differ from one application to another [3, 8]. Therefore, it is desirable to support common message-passing interfaces even on shared-memory multiprocessors, It is well known that uniform-memory-access machines, which are typically bus-based, do not scale well. Two main types of non-uniform memory access shared-memory archltectures have been proposed. Cache coherent NUMA (CCNUMA) machines have a permanent ‘home’ address for each location. Memory locations can be cached in individual processor caches and a cache coherence scheme is used to keep memory in a valid state. In comparison, cache-coherent cache-only memory access (CC-COMA) architectures have no fixed home associated with memory locations. Locations are replicated and migrated at the main-memory level, which is structured as a large attraction memorg [7]. CC-NUMA can provide good performance through a combination of page level migration and replication (done in system software) if data structures can be partitioned across the available processor memories so that there is little or no remote data access, and such sharing happens on a coarse granularity. However, if the shared accesses are fine-grained, and access patterns are dynamic, system software typically finds it difficult to cope. As a result, CCCOMA tends to perform better than CC-NUMA under such circumstances [l O]. There is a large class of irregular applications that belong to this latter category. Therefore,