We present the first dynamic shortest paths algorithms that make any progress beyond a long-standing <i>O</i>(<i>n</i>) update time barrier (while maintaining a reasonable query time), although it is only progress for not-too-sparse graphs. In particular, we obtain new decremental algorithms for two approximate shortest-path problems in unweighted, undirected graphs. Both algorithms are randomized (Las Vegas).
 • Given a source <i>s</i>, we present an algorithm that maintains (1 + ε)-approximate shortest paths from <i>s</i> with an expected <i>total</i> update time of <i>Õ</i>(<i>n</i><sup>2+<i>O</i>(1/√log <i>n</i>)</sup>) over all deletions (so the amortized time is about <i>Õ</i>(<i>n</i><sup>2</sup>/<i>m</i>)). The worst-case query time is constant. The best previous result goes back <i>three</i> decades to Even and Shiloach [16] and Dinitz [12]. They show how to decrementally maintain an <i>exact</i> shortest path tree with a total update time of <i>O</i>(<i>mn</i>) (amortized update time <i>O</i>(<i>n</i>)). Roditty and Zwick [22] have shown that <i>O</i>(<i>mn</i>) is actually optimal for <i>exact</i> paths (barring a better combinatorial algorithm for boolean matrix multiplication), unless we are willing to settle for a Ω(<i>n</i>) query time. In fact, until now, even <i>approximate</i> dynamic algorithms were not able to go beyond <i>O</i>(<i>mn</i>).
 • For any fixed integer <i>k</i> ≥ 2, we present an algorithm that decrementally maintains a distance oracle (for <i>all pairs</i> shortest distances) with a total expected update time of <i>Õ</i>(<i>n</i><sup>2+1/<i>k</i>+<i>O</i>(1/√log <i>n</i>)</sup>) (amortized update time about <i>Õ</i>(<i>n</i><sup>2+1/<i>k</i></sup>/<i>m</i>). The space requirement is only <i>O</i>(<i>m</i> + <i>n</i><sup>1+1/<i>k</i></sup>), the stretch of the returned distances is at most 2<i>k</i> − 1 + ε, and the worst-case query time is <i>O</i>(1). The best previous result of Roditty and Zwick [21] had a total update time of <i>Õ</i>(<i>mn</i>) and a stretch of 2<i>k</i> − 1. Note that our algorithm implicitly solves the decremental all-pairs shortest path problem with the same bounds; the best previous approximation algorithm of Roditty and Zwick [21] returned (1 + ε) approximate distances, but used <i>O</i>(<i>n</i><sup>2</sup>) space, and required <i>Õ</i>(<i>mn</i>) total update time. As with the previous problem, our algorithm is the first to make progress beyond the <i>O</i>(<i>mn</i>) total update time barrier while maintaining a small query time.
 We present a general framework for accelerating decremental algorithms. In particular, our main idea is to run existing decremental algorithms on a sparse subgraph (such as a spanner or emulator) of the graph rather than on the original graph <i>G</i>. Although this is a common approach for <i>static</i> approximate shortest-path problems, it has never been used in a decremental setting because maintaining the subgraph <i>H</i> as edges are being deleted from <i>G</i> might require <i>inserting</i> edges into <i>H</i>, thus ruining the "decrementality" of the setting. We overcome this by presenting an emulator whose maintenance only requires a limited number of well-behaved insertions.
 In other words, we present a general technique for running decremental algorithms on a sparse subgraph of the graph. Once our framework is in place, applying it to any particular decremental algorithm only requires trivial modifications; most of the work consists of showing that these algorithms <i>as they are</i> still work in our restricted fully dynamic setting, where we encounter not just arbitrary deletions (as in the original setting), but also restricted insertions.