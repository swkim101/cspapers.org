Given a bipartite graph G = (A ∪ B, E) where each vertex ranks its neighbors in a strict order of preference, we consider the problem of computing a largest matching in the set of popular matchings in G. A matching M is said to be popular if there is no matching where more vertices are happier than in M. The set of popular matchings is non-empty since every stable matching is popular and it is known that stable matchings always exist in G. The problem of computing a popular matching of maximum size in G = (A ∪ B, E) was considered in [8] where an O(mn0) algorithm was shown, where m = |E| and n0 = min(|A|, |B|). Here we show an O(m) algorithm for this problem. 
 
A largest popular1 matching need not be a maximum cardinality matching in G. There are many applications where maximum cardinality is one of the requirements, and so the next problem that we consider is the following: if M is the set of maximum cardinality matchings in G, compute M* ∈ M that is popular within M. That is, we want a maximum cardinality matching M* such that there is no matching in M that is more popular than M*. We show that such a matching M* always exists and can be computed in O(mn0) time. 
 
Though the above matching M* is popular in the set of maximum cardinality matchings, in the entire set of matchings in G, its unpopularity factor could be as high as n0 − 1. On the other hand, a largest popular matching could be of size only 2/3|M*|. In between these two extremes, we show that there is an entire spectrum of matchings: for any integer k, where 2 ≤ k ≤ n0, there is a matching Mk in G of size at least k/k+1|M*| whose unpopularity factor is at most k − 1; also such a matching Mk can be computed in O(mk) time by a simple generalization of our largest popular matching algorithm.