Introduction: review of basic computer architecture, quantitative techniques in computer design, measuring and reporting performance. CISC and RISC processors. Time operating system issues with respect to embedded system applications; time constraints and performance analysis. Theory and implementation aspects of distributed operating systems. Process synchronization in multiprocessing/multiprogramming systems. Inter-process communication and coordination in large distributed systems. Distributed resource management. Fundamentals of real time operating systems. Case studies. Information management in distributed systems: security, integrity and concurrency problems. Fault tolerance issues. OS issues related to the Internet, intranets, pervasive computing, embedded systems, mobile systems and wireless networks. Case studies of contemporary operating systems. on fault coverage. PLA testing: cross-point fault model, test generation, easily testable designs. Memory testing: permanent, intermittent and pattern-sensitive faults; test generation. Delay faults and hazards; test generation techniques. Test pattern generation for sequential circuits: ad-hoc and structures techniques, scan path and LSSD, boundary scan. Built-in self-test techniques. Verification: logic level (combinational and sequential circuits), RTL-level (data path and control path). Verification of embedded systems. Use of formal techniques: decision diagrams, logic-based approaches. compilers for imperative, object-oriented and markup languages, parallel and distributed programming and concurrency. Fundamental concepts in the theory of reliable computer systems design. Introduction to redundancy theory, limit theorems; decision theory in redundant systems. Hardware fault tolerance, redundancy techniques, detection of faults, replication and compression techniques, self-repairing techniques, concentrated and distributed voters, models of fault tolerant computing systems. Case studies. Software fault tolerance: fault tolerance versus fault intolerance, errors and their management strategies. Implementation techniques: software defense, protective redundancy, architectural support. Fault recovery techniques. Coding theory: application to fault tolerant system design. Fault-tolerance and reliability of multicomputer networks (direct and indirect) including fault-tolerant routing and sparing techniques. Yield and reliability enhancement techniques for VLSI/WSI array processors. Formal languages and their related automata, Turing machines, type-0 languages, linear bounded automata and CSLs. Time and tape bounded Turing machines, time and space bounds for recognizing CFLs. Turing Computability: number theoretic computations by Turing machines and indexing. Axiomatic systems, their soundness and completeness. Recursive function theory: primitive recursive functions and primitive recursive predicates. Ackermann's function, recursive and general recursive functions. Computability and decidability: computable functions, computable sets, decision problems. Fixpoint theory of programs, functions and functionals, verification methods, Lambda calculus and applications. and linear progarmming in d-dimensions, complexity of the union of convex sets, simply connected sets and visible regions; Sweep techniques: plane sweep for segment intersections, Fortune's sweep â€¦