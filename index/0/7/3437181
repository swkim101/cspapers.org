More than 25 years ago, inspired by applications in computer graphics, Chazelle \etal (FOCS 1991) studied the following question: Is it possible to cut any set of n lines or other objects in \Reals^3 into a subquadratic number of fragments such that the resulting fragments admit a depth order? They managed to prove an O(n^{9/4}) bound on the number of fragments, but only for the very special case of bipartite weavings of lines. Since then only little progress was made, until a recent breakthrough by Aronov and Sharir (STOC 2016) who showed that O(n^{3/2}\polylog n) fragments suffice for any set of lines. In a follow-up paper Aronov, Miller and Sharir (SODA 2017) proved an O(n^{3/2+&#x2265;}) bound for triangles, but their method uses high-degree algebraic arcs to perform the cuts. Hence, the resulting pieces have curved boundaries. Moreover, their method uses polynomial partitions, for which currently no algorithm is known. Thus the most natural version of the problem is still wide open: Is it possible to cut any collection of n disjoint triangles in \Reals^3 into a subquadratic number of triangular fragments that admit a depth order? And if so, can we compute the cuts efficiently?We answer this question by presenting an algorithm that cuts any set of n disjoint triangles in \Reals^3 into O(n^{7/4}\polylog n) triangular fragments that admit a depth order. The running time of our algorithm is O(n^{3.69}). We also prove a refined bound that depends on the number, K, of intersections between the projections of the triangle edges onto the xy-plane: we show that O(n^{1+&#x2265;} + n^{1/4} K^{3/4}\polylog n) fragments suffice to obtain a depth order. This result extends to xy-monotone surface patches bounded by a constant number of bounded-degree algebraic arcs in general position, constituting the first subquadratic bound for surface patches. Finally, as a byproduct of our approach we obtain a faster algorithm to cut a set of lines into O(n^{3/2}\polylog n) fragments that admit a depth order. Our algorithm for lines runs in O(n^{5.38}) time, while the previous algorithm uses O(n^{8.77}) time.