In the domain of hard real-time systems, which language is better: C++ or the Real-Time Specification for Java (RTSJ)? Although standard Java provides a more productive programming environment than C++ due to automatic memory management, that benefit does not apply to RTSJ when using NoHeapRealtimeThread and non-heap memory areas. As a result, RTSJ programmers must manage non-heap memory explicitly. Although that's a common practice in real-time applications, it's also a common source of programmer error, regardless of language. In an ironic role reversal, this paper shows that C++ is able to provide a safer programming environment than RTSJ (or C) for managing memory in a hard-real-time producer/consumer pattern. C++ accomplishes this via a reference-counting pointer. RTSJ (and C) cannot provide an equivalent mechanism because it lacks the necessary language features. Despite other attractive features of RTSJ, the relative simplicity and safety of the C++ programming model for this common pattern suggests that C++ will be a strong competitor to RTSJ in the domain of real-time mission-critical systems.