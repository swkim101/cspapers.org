An <italic> m x n</italic> matrix A is called totally monotone if for all <italic>i<subscrpt>1</subscrpt> < i<subscrpt>2</subscrpt></italic> and <italic>j<subscrpt>1</subscrpt> < j<subscrpt>2</subscrpt>, A[i<subscrpt>1</subscrpt>, j<subscrpt>1</subscrpt>] > A[i<subscrpt>1</subscrpt>, j<subscrpt>2</subscrpt]</italic> implies <italic>A[i<subscrpt>2</subscrpt>, j<subscrpt>1</subscrpt>] > A[i<subscrpt>2</subscrpt>, j<subscrpt>2</subscrpt>]</italic>. We consider the complexity of comparison-based selection and sorting algorithms in such matrices. Although our selection algorithm counts only comparisons its advantage on all previous work is that it can also handle selection of elements of different (and arbitrary) ranks in different rows (or even selection of elements of several ranks  in each row), in time which is slightly better than that of the best known algorithm for selecting elements of the <italic>same</italic> rank in each row. We also determine the decision tree complexity of sorting each row of a totally monotone matrix up to a factor of at most log <italic>n</italic> by proving a quadratic lower bound and by slightly improving the upper bound. No nontrivial lower bound was previously known for this problem. In particular for the case <italic>m = n</italic> we prove a tight &OHgr;(<italic>n<supscrpt>2</supscrpt></italic>) lower bound. This bound holds for any decision-tree algorithm, and not only for a comparison-based algorithm. The lower bound is proved by an exact characterization of the bitonic totally monotone matrices, whereas our new algorithms depend  on techniques from parallel comparison algorithms.