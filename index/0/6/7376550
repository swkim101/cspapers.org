An experimental study of strongly universal hashing is presented, including non-standard usage of the floating point co-processor. Gains of up to a factor 15 are obtained over naive implementations of the classical (az + b) mod scheme. Strongly universal hashing. For hashing we are interested in getting a random-like function h from some universe U = {0,..., m}, m = 2% of keys into a domain D = {0, ..., n-1}, n-=-2 l of hash va!ues. As theoreti-cians, we do this by selecting h uniformly at random from some specific class 7-/of functions from U to D. We say that 7/is universal if it guarantees low collision probability , i.e. Vz ~ y 6 U : Prh~n (h(z) = h(y)) = O(1/n) [2]. Further, 7/is strongly universal if keys are mapped pairwise independently, i.e. if Vz ~ y 6 U, o~, fl 6 D : Prhen(h(x) = ~ A h(y) =/3) = O(1/n 2) [9]. Note that if U = D and 7-/ = {id} consists of the identity function, 7-/ is universal, but not strongly universal. Whereas universality suffices for the classical dictionary applications, it fails to generate pseudo-random numbers. Also it fails to support the following type of vector hashing [2]: LEMMA 1. Suppose 7-[ is strongly universal. Let 7£ q define the class of functions from U q to D such that (hl,...,hq)(Xl,...,Xq) = hl(Zl) ~)"'~)hq(xq). Then 7£q is strongly universal. To see that universality does not suffice for the above vector hashing, note that {id} is universal whereas {id}q is not universal as it is constant over all permutations of the coordinates. A particularly nice feature of vector hashing is that if ~' is obtained from i locally replacing one coordinate xi by z~, then h(Z) = h(~-) @ hi(xi) ~ hi(z~). One natural application is local search heuristics: feasible solutions are high-dimensional vectors. To avoid cycling, we tabulate hash values of visited solutions. The neighborhood of the current solution is obtained by local changes whose hash values can quickly be found and checked. Note that typical heuristics for string hashing [1, 8] do not allow such local updates of hash values. Implementations. Two classical hashing schemes are the division method and the multiplication method [7]. In the division method, we fix some prime p _> max{m, n}, and then each member of 7/is characterized by two members a and b of X~,. Given a and …