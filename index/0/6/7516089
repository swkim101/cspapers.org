The <i>rank index problem</i> is the following: Preprocess and store a bit string <i>x</i> ∈ {0,1}<sup><i>n</i></sup> on a random access machine with word size <i>w</i> so that <i>rank</i> queries "What is Σ<sup><i>j</i></sup><inf><i>i</i>=1</inf> <i>x</i><inf><i>i</i></inf>?" for arbitrary values of <i>j</i> can afterwards be easily answered. The <i>selection index problem</i> is the following: Preprocess and store a bit string <i>x</i> ∈ {0,1}<sup><i>n</i></sup> so that <i>selection</i> queries "What is the index of the <i>j</i>'th 1-bit in <i>x</i>?" for arbitrary values of <i>j</i> can afterwards be easily answered. The data structure representing <i>x</i> should be an <i>index structure</i>, i.e., the <i>n</i>-bit string <i>x</i> is kept <i>verbatim</i> in [<i>n</i>/<i>w</i>] words and the preprocessing phase adds an <i>r</i>-bit <i>index</i> φ(<i>x</i>) with additional information contained in [<i>r/w</i>] words. We are interested in tradeoffs between <i>r</i>, the size of the index measured in bits (the <i>redundancy</i> of the scheme), and <i>t</i>, the worst case time for answering a query.