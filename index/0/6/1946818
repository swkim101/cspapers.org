We propose a version of cache oblivious search trees which is simpler than the previous proposal of Bender, Demaine and Farach-Colton and has the same complexity bounds. In particular, our data structure avoids the use of weight balanced <i>B</i>-trees, and can be implemented as just a single array of data elements, without the use of pointers. The structure also improves space utilization.For storing <i>n</i> elements, our proposal uses (1 + ε)<i>n</i> times the element size of memory, and performs searches in worst case <i>O</i>(log<inf><i>B</i></inf> <i>n</i>) memory transfers, updates in amortized <i>O</i>((log<sup>2</sup> <i>n</i>)/(ε<i>B</i>)) memory transfers, and range queries in worst case <i>O</i>(log<inf><i>B</i></inf> <i>n + k/B</i>) memory transfers, where <i>k</i> is the size of the output.The basic idea of our data structure is to maintain a dynamic binary tree of height log <i>n+O</i>(1) using existing methods, embed this tree in a static binary tree, which in turn is embedded in an array in a cache oblivious fashion, using the van Emde Boas layout of Prokop.We also investigate the practicality of cache obliviousness in the area of search trees, by providing an empirical comparison of different methods for laying out a search tree in memory.