A secret-ballot vote for a single proposition is an example of a secure distributed computation. The goal is for <italic>m</italic> participants to jointly compute the output of some <italic>n</italic>-ary function (in this case, the sum of the votes), while protecting their individual inputs against some form of misbehavior.
In this paper, we initiate the investigation of the communication complexity of unconditionally secure multi-party computation, and its relation with various fault-tolerance models. We present upper and lower bounds on communication, as well as tradeoffs among resources.
First, we consider the “direct sum problem” for communications complexity of perfectly secure protocols: Can the communication complexity of securely computing   a single function <italic>f</italic> : F<supscrpt>n</supscrpt> → <italic>F</italic> at <italic>k</italic> sets of inputs be smaller if all are computed simultaneously than if each is computed individually? We show that the answer depends on the failure model. A factor of <italic>O(n</italic>/log <italic>n</italic>) can be gained in the privacy model (where processors are curious but correct); specifically, when <italic>f</italic> is <italic>n</italic>-ary addition (mod 2), we show a lower bound of &OHgr;(<italic>n</italic><supscrpt>2</supscrpt> log <italic>n</italic>) for computing <italic>f O</italic>(<italic>n</italic>) times simultaneously. No gain is possible in a slightly stronger fault model (fail-stop mode); specifically, when <italic>f</italic> is <italic>n</italic>-ary  addition over  <italic>GF</italic>(<italic>q</italic>), we show an exact bound of &THgr;(<italic>kn</italic><supscrpt>2</supscrpt> log <italic>q</italic>) for computing <italic>f</italic> at <italic>k</italic> sets of inputs simultaneously (for any <italic>k</italic> ≥ 1).
However, if one is willing to pay an additive cost in fault tolerance (from <italic>t</italic> to <italic>t</italic>-<italic>k</italic>+1), then a variety of known non-cryptographic protocols (including “provably unparallelizable” protocols from above!) can be systematically compiled to compute one function at <italic>k</italic> sets of inputs <italic>with no increase in communication complexity</italic>. Our compilation technique is based on a new compression idea of polynomial-based  multi-secret  sharing.
Lastly, we show how to compile private protocols into error-detecting protocols at a big savings of a factor of <italic>O</italic>(<italic>n</italic><supscrpt>3</supscrpt>) (up to a log factor) over the best known error-correcting protocols. This is a new notion of fault-tolerant protocols, and is especially useful when malicious behavior is infrequent, since error-detection implies error-correction in this case.