We identify three distinct types of hardware/software codesign: 1. Joint design of an instruction-set architecture and its program. 2. Synthesis of hardware and/or software from a common specification. These can be viewed as manifestations of heterogeneity in the design methodology. The first type concerns the joint synthesis of a data-path and its controller, two conceptually distinct parts of a processor [Pau93]. The heterogeneity in this approach is limited to distinguishing the datapath from its controller. In type 2, a unified representation of an application is mapped into some mixture of implementation technologies. For example, a dataflow graph could be partitioned, and the separate partitions could be fed to hardware and software synthesis tools [Kal93]. The software components execute on commodity processors , or possibly on processors synthesized as in type 1. A hierarchical finite state machine could also be converted to hardware or software implementations [Har90]. If concurrent FSMs are used, then a mixture of hardware implementations might be attractive. In type 2, the heterogeneity is limited to distinguishing implementation technologies; the model of computation is unified. In type 3, the design representation need not be unified. Distinct models of computation can be used for different parts of the design. The model of computation for each component would be chosen on the basis of the properties of that component. For instance, dataflow would be used for signal processing, and hierarchical FSMs for control. A typical application could combine both models of computation. Within each model of computation, types 1 or 2 might apply in synthesizing the implementations. Type 3 addresses a large cross section of system-level design problems. In the signal processing domain, for example, most applications combine some hard-real-time numerical processing of signals with much more dynamic control. In applications such as modems, wireless communication systems, video phones, voice mail systems, voice recognition systems, disk-drive controllers, and data compression, one or more signal processing kernels are invoked in response to outside stimuli. For example, a modem needs to negotiate a common transmission format with another modem when a connection is established, or when a wireless device moves from one service area to another. Type 1 is fundamentally still a chip-level design problem. It can be viewed as an approach to high-level synthesis. In this paper, we concentrate on system-level problems, and hence on types 2 and 3. In this context, four key problems emerge: • partitioning • synthesis • …