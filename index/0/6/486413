1 I n t r o d u c t i o n There are two main purposes of graph visualization: The first one is to show small or medium sized graphs in an exquisite way as it can be done manually. The second goal is to visualize structural properties of large graphs. Methods of automatic drawing mainly try to meet the second demand, they follow certain criteria, such as minimizing the area, the number of crossings, and so on. Only a small number of methods have been developed to support user interaction and to keep the algorithms flexible enough to incorporate user requirements for parts of the drawing. Examples of such constraints are • the directions of the edges are prescribed (upward, rightward) • the places are fixed, where certain edges are attached to the vertices (port constraints) • some segments of the edges have a certain length (to enable labeling!). Attempts to include constraints in graph drawing algorithms have been mostly directed to global requirements such as 'no crossings are allowed' (for planar graphs), 'upward drawings' (Sugiyama style), etc. (see [6] for an overview.) All these approaches lack the flexibility to ---rWilhelm-Schickard-Institut fiir Informatik, Universit[it Tiibingen, Sand 13, D-72076 Tfibingen, Germany. E-maih eiglsper@informatik.uni-tuebingen.de tTom Sawyer Software, 804 Hearst Avenue, Berkeley, CA 94710. email: foessmei@tomsawyer.com ¢Wilhelm-Schickard-Institut ffir Informatik, Universit~it Tfibingen, Sand 13, D-72076 Tfibingen, Germany. E-mail: mkQinformatik.uni-tuebingen.de specify different constraints for different sets of vertices or edges. The few existing approaches towards flexible incorporation of constraints are heuristics based on force directed methods [20]. Their performance is very limited for medium and large graphs, and only a quite small set of constraints could be realized so far. For orthogonal drawings, which play a key role in the visualization of data and their relations, especially in the areas of da ta bases, CASE tools and software engineering (UML), the success to incorporating any constraints was even more limited. The most effective general approach for orthogonal drawings is the GIOTTO concept [22], which works in three phases: In the first phase, an embedding for the drawing is computed and crossings are replaced by dummy vertices, so that the resulting graph is planar and the embedding is prescribed. Then, from the given planar embedding, the so called orthogonai representation is computed, showing the sequence of bends for each edge. Finally, in the compaction phase, the final coordinates are computed according to the orthogonal representation. While the first and third phases are traditionally done by heuristics [21] and only recently by advanced methods from graph data structures [9] and optimization [18], the second phase was able to be solved efficiently, so that bendminimal solutions can be provided. This phase, which is originally based on a mincost-flow approach, is primarily responsible for the success of the method; in experiments it clearly outperformed all other methods considered [8]. Several groups have tried to incorporate constraints into these methods [3, 4] but with limited success. They considered dynamic versions of the problem, where the user can insert (delete) edges and vertices and restrict the number of bends on each edge. This naturally follows from the mincost-flow formulation in phase 2. The original version of GIOTTO could only draw planar graphs with a maximum vertex degree of four at the very most. More developed versions were able to reduce this restriction in extending the size of highdegree vertices, but this approach led to huge vertices with an even unbounded size. In Kandinsky [13, 14], we extended the concept such that graphs with a degree larger than four can be drawn without losing control