In this paper we introduce the concept of a victim cache for the register level of a vector processor. This small cache holds full vectors \evicted" from the register level through store instructions. The goal of this cache is to lter out the abundant spill code present in vector programs. Using a trace driven simulation technique we compare the performance of a conventional vector implementation with and without the addition of the victim cache proposed. We study a write-through victim cache that eliminates around a 5{20% of load spill traac and provides speedups in the range 1.06{1.20. In order to allow elimination of store spill traac, we also present a write-back victim cache that increases the amount of traac eliminated up to the 10{50% range. Finally, we study the behavior of the victim cache under diierent memory latencies and show that the victim allows a good tolerance of large memory latencies and can provide speedups as large as 1.24. 1 Introduction Spill code is a serious problem on architectures that have a limited number of registers at the ISA level. The small number of logical registers available to the programmer or compiler induce extra traac between the processor and the next memory level in four diierent ways. First, when the compiler runs out of registers it must insert store and load instructions to spill and reload a register to the stack. Second , a register may be loaded from memory, but the data can not be saved for long because the register is needed for some other instruction. When the memory data is needed again, it must be reloaded. Third, variables that are reused between close iterations of a given loop are diicult to keep in the register le due to the high register pressure. Optimizations such as scalar replacement 1] are hardly useful