Motivated by a concrete problem and with the goal of understanding the relationship between the complexity of streaming algorithms and the computational complexity of formal languages, we investigate the problem Dyck(s) of checking matching parentheses, with s different types of parenthesis.
 We present a one-pass randomized streaming algorithm for Dyck(2) with space O(√ n log(n)) bits, time per letter polylog(n), and one-sided error. We prove that this one-pass algorithm is optimal, up to a log(n) factor, even when two-sided error is allowed, and conjecture that a similar bound holds for any constant number of passes over the input.
 Surprisingly, the space requirement shrinks drastically if we have access to the input stream "in reverse". We present a two-pass randomized streaming algorithm for Dyck(2) with space O((log n)2), time polylog(n) and one-sided error, where the second pass is in the reverse direction. Both algorithms can be extended to Dyck(s) since this problem is reducible to Dyck(2) for a suitable notion of reduction in the streaming model. Except for an extra O(√ log(s)) multiplicative overhead in the space required in the one-pass algorithm, the resource requirements are of the same order.
 For the lower bound, we exhibit hard instances Ascension(m) of Dyck(2) with length Θ(mn). We embed these in what we call a "one-pass" communication problem with 2m-players, where m=~O(n). To establish the hardness of Ascension(m), we prove a direct sum result by following the "information cost" approach, but with a few twists. Indeed, we play a subtle game between public and private coins for Mountain, which corresponds to a primitive instance Ascension(1). This mixture between public and private coins for m results from a balancing act between the direct sum result and a combinatorial lower bound for m.