Priority queues are some of the most fundamental data structures. For example, they are used directly for task scheduling in operating systems. Moreover, they are essential to greedy algorithms. We study the complexity of integer priority queue operations on a RAM with arbitrary word size, modeling the possibilities in standard imperative programming languages such as C. We present exponential improvements over previous bounds, and we show tight relations to sorting. 
Our first result is a RAM priority queue supporting find-min in constant time and insert and delete-min in time O(log log n), where n is the current number of keys in the queue. This is an exponential improvement over the $O(\sqrt{\log n})$ bound of Fredman and Willard [ Proceedings of the 22nd ACM Symposium on the Theory of Computing, Baltimore, MD, pp. 1--7]. Plugging this priority queue into Dijkstra's algorithm gives an O(mlog log m) algorithm for the single source shortest path problem on a graph with m edges, as compared with the previous $O(m\sqrt{\log m})$ bound based on Fredman and Willard's priority queue. The above bounds assume $O(n 2^{{\varepsilon} w})$ space, where w is the word length and ${\varepsilon}>0$. They can, however, be achieved in linear space using randomized hashing. 
Our second result is a general equivalence between sorting and priority queues. A priority queue is monotone if the minimum is nondecreasing over time, as in many greedy algorithms. We show that on a RAM, the amortized operation cost of a monotone priority queue is equivalent to the per-key cost of sorting. For example, the equivalence implies that the single source shortest paths problem on a graph with m edges is no harder than that of sorting m keys. With the current RAM sorting, this gives an O(m log log m) time bound, as above, but the relation holds regardless of the future developments in RAM sorting. 
From the equivalence result, for any fixed ${\varepsilon}>0$, we derive a randomized monotone $O(\sqrt{\log n}^{1+{\varepsilon}})$ priority queue with expected constant time decrease-key. Plugging this into Dijkstra's algorithm gives an $O(n\sqrt{\log n}^{1+{\varepsilon}}+m)$ algorithm for the single source shortest path problem on a graph with n nodes and m edges, complementing the above O(mlog log m) algorithm if $m\gg n$. This improves the O(nlog n/log log n + m) bound by Fredman and Willard [Proceedings of the 31st IEEE Symposium on the Foundations of Computer Science, St. Louis, MO, 1990, pp. 719--725], based on their O(log n/log log n) priority queue with constant decrease-key.