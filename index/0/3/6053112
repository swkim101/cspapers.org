The focus of formal verification is how to verify mathematically that a system of coordinating components behaves as it should. In this context, the “system” typically is a hardware and/or software implementation of a control algorithm. Examples include controllers which implement communication protocols, cache coherency protocols and telephone switches. However, for our purposes, a system may as well be a subcircuit which implements an adder, a state machine implementing a lexical parser, a game such as nim, or a discrete-event economic model. The real-time behavior of systems also may be analyzed in this context, as long as the tested attributes are discrete events. 1 Given a mathematical model of such a system, one seeks to verify that the model has a given attribute. The attribute could be that all modelled behaviors are consistent with another model. The second model may represent a single aspect of the first model, such as “every message is eventually delivered”, “all cache reads are consistent”, “ add(a, b) = a + b“, “black wins in 3“ and so on. Generally speaking, formal verification may be construed as theorem-proving in a given logic. However, in practice, research in formal verification falls within various subcategories. The oldest and most general form of computer-aided formal verification is this: given two formulae j, g in a reasonably expressive logic, prove f +g. This most general form has been studied and practiced since before 1960, under the name automated theorem-proving.z While results in au-