An m-component, n-process snapshot object is an abstraction of shared memory that consists of m words and allows up to n processes to concurrently execute the following two types of operations: write(i,v), which writes v into the ith word, and scan(), which returns the current values of all m locations [1, 3]. The snapshot problem is to design algorithms for the write and scan operations that meet two challenging requirements: (1) operations appear to be atomic, and (2) operations are wait-freeFor any (m-component, n-process) snapshot algorithm, which runs on hardware that supports only word-sized objects, Ω(1) and Ω(m) are trivial lower bounds on the time complexity of write(i,v) and scan(), respectively. But, are these bounds tight?For a restricted version of the snapshot problem, known in the literature as the single-writer snapshot problem, Riany, Shavit and Touitou [18] showed that the answer is yes: they designed an algorithm with O(1) and O(m) running times for the write(i,v) and scan() operations, respectively. (The single-writer snapshot problem assumes that (i) the number m of words of the snapshot object is equal to the number n of processes, and (ii) only the ith process may write into the ith snapshot word.This paper shows that the same (optimal) running times of O(1) for write(i,v) and O(m) for scan() are achievable for the general problem, known in the literature as the multiwriter snapshot problem. Our algorithm requires hardware support for the CAS (compare&swap) operation (in comparison, Riany, Shavit and Touitou's algorithm requires hardware support for CAS, fetch&inc, and fetch&dec operations).