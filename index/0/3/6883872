This paper presents a step forward in the use of partial evaluation for interpreting and compiling programs, as well as for automatically generating a compiler from denotationrd definitions of programming languages. We determine the static and dynamic semantics of a programming language, reduce the expressions representing the static semantics, and generate object code by instantiating the expressions representing the dynamic semantics. By processing the static semantics of the language, programs get compiled. By processing the static semantics of the partial evaluator, compilers are generated. The correctness of a compiler is guaranteed by the correctness of both the executable specification and our partial evaluator. The results reported in this paper improve on previous work in the domain of compiler generation [16, 30], and solves several open problems in the domain of partial evaluation [15]. In essence: ● Our compilation goes beyond a mere syntax-tosemantics mapping since the static semantics gets processed at compile time by partial evaluation. It is really a syntax-to-dynamic-semantics mapping. Q Because our partial evaluator is self-applicable, a compiler is actually generated. ● Our partial evaluator handles non-flat binding time domains. Our source programs are enriched with an open-ended set of algebraic operators. This experiment parallels the one reported by Montenyohl and Wand in [24]: starting with the same denot ational semantics of an Algol subset, we obtain the same good results, bnt completely automatically and using the original semantics only, instead of writing several others, which requires proving their congruence. We are able to compile strongly typed, Algol-like programs and to process their static semantics at compile time (scope resolution, storage calculation, and type checking), as well ax to generate the corresponding compiler completely automatically. “ P.O. Box 2158, New Haven, CT 06520, USA. This research was supported by Darpa under grant NOOO14-88-k-0573. ‘Manhattan, KS 66506, USA Permission to copy without fee all or part of this material is granted provided that the copies are not made or distributed for direct cotntnercial advantage, the ACM copyright notice and the title of the publication and its date appear, and notice is given that copying is by permission of the Association for Computing Machinery. To copy otherwise . or to republish, requires a fee and/or specific permission. @ 1990 ACM 089791-419-8/90/0012/0014 $1.50 The object code is reasonably efficient. It has been found to be more than a hundred times faster than the interpreted source program, whereas it runs about two times slower than the out put of a regular, production-qualit y compiler. The compiIer is well-structured and efficient. The static semantics stiU gets processed at compile time. Self-application pays off: compiling using the compiler is correspondingly much faster than compiling by partially evaluating the interpreter with respect to the source program. Our compiler is still slower than a production-quality one, but we derived it automatically.