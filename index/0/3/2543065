Speculative query evaluation is the process of answering queries over databases containing objects that serve as compact representations for very large search spaces. Such objects occur naturally in scheduling, planning and engineering applications. The basic idea behind efficient evaluation of speculative queries is the ability to construct a subset of the database, called a witness of the query, which is sufficient to answer the query. In some cases, it is more efficacious to construct counter witnesses that are sufficient to falsify a query because early falsification reduces the work involved. We also introduce a third kind of witness whose behavior is socinian in the sense that it is not omnipotent but its ability to answer queries grows as the database changes. Finally, we introduce a notion of sentinels that are subsets of a database designed in such a way that a pre-determined set of queries to a sentinel is guaranteed to have efficient evaluations. *Bell Communications Research, Morristown, NJ. Email: shamim@lbellcore .com t Rutgers University, New Brunswick NJ. Email: imielins@cs.rut gers.edu t Be~ Comuficatiom Re~e=ch, Momistown, NJ. Em~l: madhur@bellcore .com $Case western Reserve University, Cleveland OH. Email: kumarv@alpha.ces. cwru.edu Permission to copv without fee all or part of this materiel is granted protided that the copiee w not medo or distributed for direct commercial edvanteg% the ACM cop~ight notice ●nd the title of the publication and its date appear, and notice is given 1 Motivation Scheduling a group of people to visit several places at certain times, or assigning resources to a number of people so as to satisfy certain constraints are basic and fundamental telecommunications operations. In their most general form, these problems belong to a class that is known to be intrinsically hard in the sense that finding an optimal solution may take time that is exponential in the size of the data. Less general versions of these problems are amenable to efficient algorithms that are known to generate optimal solutions. For the general hard case, approximate algorithms may be used to derive close to optimal solutions. Often, however, there is an equally important need to query certain aspects of one or more schedules. Consider, for example, the sit uation where several people in a department are to be scheduled to visit one or more of several places at certain times. One member oft he department, for example, may have the choices San Francisco in June, Paris in August, or Ausiin in December. The department itself may have general constraints precluding two people from visiting the same town at the same time. It may also, for instance, have a limited travel budget. Various optimization algorithms allow us to find an optimal assignment of people to places, i.e., a schedule, that does not violate the known constraints, if such a schedule exists. If we are dealing with a large number of people and that copying ie by permission of the Amocietion for Computing Machinery. To copy otherwise, or to republish, requiree e fee ●ndbr ●pecifio permission. CIKM ’93-1 l/83/D. C., USA @ 1993 AcM ()-89791-fj26-3~3/oOl 1....$1.50 439 places we can use an approximate algorithm and get a close to optimal solution. In each case we can say that the algorithm provides an answer to the query “Find a valid schedule.” The question is how should an optimization algorithm proceed if we ask the query “1s it possible for Stu to visit San Francisco in June?” Such a query inquires about the properties of the possible schedules rather than finding an optimal or a close to optimal solution. It is not clear how a given optimization algorithm can be made to work for this class of queries because the algorithms for finding exact solutions are rigid and use specialized techniques for finding the best solution. Approximate algorithms use powerful heuristics to prune away large subsets of the search space. Extending such algorithms to generate a set of solutions that satisfy certain ad-hoc conditions may destroy their basic mathematical properties. Even if such an extension were possible, the question is whether such a set should be generated? After all, we are not interested in the schedule, only in the structural properties of that schedule. Another argument for querying schedules can be made if we assignment problem in which a the structure of consider the regiven schedule is changed to accommodate a new constraint. For example, suppose we have a schedule and later we discover that Stu can not go to San Francisco in December. One possibility is to run whatever procedure was used before to derive a new assignment. This may be impractical because a number of people may get new assignments. Another solution would be to take the previous solution and ask for a new one that is minimally different from it and which incorporates the change. In telecommunications operations this problem, called the the “pending-on-pending” problem, occurs frequently because resources may be allocated and schedules drawn based upon conditional availability of resources at some future date. A cancellation of these conditional events forces are-scheduling. We propose that objects representing large numbers of schedules, plans or designs be stored in a database. Such objects then serve as compact representations for large search spaces. Because of the large sizes of these spaces, it would be highly inefficient to search them exhaustively. Therefore, we need to devise query evaluation techniques that operate only on the compact representations in the database, and not on the implied search space. We use the term speculative to describe such query evaluation techniques. The basic idea underlying speculative query evaluation is the ability and feasibility of constructing a subset of the database which serves to answer the query. Such a subset serves as a witness for the query in the sense that it is sufficient to answer the query. In some cases, we construct counter witnesses that are sufficient to falsify a query. This may be very useful when we attempt to solve a hard query because early falsification may reduce the work involved. We also introduce a third kind of witness whose behavior lies between a witness and a counter witness. This notion is called a socantan wttness and represents the situation in which the power of a witness to answer a query grows with the database. Finally, we show some results for designing parts of a database to guarantee efficient query evaluation for a pre-determined set of queries. All our techniques are based on the represent at ions cent ained in the database.