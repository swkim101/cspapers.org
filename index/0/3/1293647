In this note we describe a general technique for making treestructured dynamic dictionaries adapt to be competitive with the most efficient implementation, by using potential energy parameters and a simple partial rebuilding scheme. Introduction. On-line algorithms deal with optimizing the performance of operation sequences (e.g., see [4, 9]). Such algorithms are desired to be -competitive [4], for some parameter , where is an upper bound on the ratio of the costs of the solution defined by the on-line algorithm and an oracle’s algorithm. In this paper we are interested in dictionary data structures that are competitive in this same sense. Our Results. We present a simple adaptive tree-based dictionary structure that is balanced and competitive. Our approach is based on a potential energy parameter stored at each node in the tree. As updates and queries are performed, the potential energy of tree nodes are increased or decreased. Whenever the potential energy of a node reaches a threshold level, we rebuild the subtree rooted at that node. We show that, in spite of its conceptual simplicity, such a scheme is constant-ratio competitive with a static oracle using a priori knowledge of the operation distribution. Related Prior Work. Besides general work for on-line algorithms (e.g., see [4, 9]) and data structures that use partial rebuilding [7], there has been some prior work on methods for adapting data structures to the way in which they are being used. Most previous data structure competitive analyses have been directed at simple linked-lists structures, with “move-to-front” heuristics applied [9]. Work on other adaptive data structures includes splay trees [10], which perform a sophisticated move-to-root heuristic, but perform many rotations with each access. There is also the randomized binary search tree of Seidel and Aragon [8], which performs random structural changes with each access and can adapt in an expected, probabilistic sense based on data structure usage. Energy-Balanced Binary Search Trees. A dictionary holds pairs of ordered keys and elements, subject to update and query operations. A common way of implementing the dictionary ADT is to use a binary search tree, which maintains balance by local rotation operations. Typically, such rotations are fast, but if the tree has auxiliary structures, rotations are often slow. Standard binary search trees, such as AVL trees [1], red-black trees [3], scapegoat trees [2], or weight-balanced trees [6], maintain balance, but do not adapt themselves based on the distribution of accesses and updates. Splay trees [10], on the other hand, adapt (in an asymptotic sense), but perform a large number of rotations with each access. Finally, randomized binary search trees [8], have good expected behavior but offer no worst-case guarantees on per-