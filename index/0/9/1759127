Regular expression matching is a key task (and often computational bottleneck) in a variety of software tools and applications. For instance, the standard grep and sed utilities, scripting languages such as perl, internet traffic analysis, XML querying, and protein searching. The basic definition of a regular expression is that we combine characters with union, concatenation, and kleene star operators. The length <i>m</i> is proportional to the number of characters. However, often the initial operation is to concatenate characters in fairly long strings, e.g., if we search for certain combinations of words in a firewall. As a result, the number <i>k</i> of strings in the regular expression is significantly smaller than <i>m</i>. Our main result is a new algorithm that essentially replaces <i>m</i> with <i>k</i> in the complexity bounds for regular expression matching. More precisely, after an <i>O</i>(<i>m</i> log <i>k</i>) time and <i>O</i>(<i>m</i>) space preprocessing of the expression, we can match it in a string presented as a stream of characters in <i>O</i>(<i>k</i> log <i>w</i>/<i>w</i> + log <i>k</i>) time per character, where <i>w</i> is the number <i>w</i> of bits in a memory word. For large <i>w</i>, this corresponds to the previous best bound of <i>O</i>(<i>m</i> log <i>w</i>/<i>w</i> + log<i>m</i>). Prior to this work no <i>O</i>(<i>k</i>) bound per character was known. We further extend our solution to efficiently handle character class interval operators <i>C</i>{<i>x, y</i>}. Here, <i>C</i> is a set of characters and <i>C</i>{<i>x, y</i>}, where <i>x</i> and <i>y</i> are integers such that 0 ≤ <i>x</i> ≤ <i>y</i>, represents a string of length between <i>x</i> and <i>y</i> from <i>C</i>. These character class intervals generalize variable length gaps which are frequently used for pattern matching in computational biology applications.