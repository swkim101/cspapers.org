A technique is presented for constructinga program from given specifications. The basic approach is to transform the specifications repeatedly, according to certain rules, until the desired program is produced. Two important transformation rules are those responsible for introducing conditional expressions and recursion into the target program. These transformations have been introduced in previous publications, and are discussed here briefly. Of ten, to construct a recursive program it is necessary to define other auxilliary programs to achieve certain subtasks of the main task. The formation of such systems of auxilliary programs is specially emphasized in this paper. T h e program synthesis techniques we discuss have been incorporated into a running system called SYNSYS. This system accepts high-level specifications expressed in mathematical notation, and produces recursive programs in pure LISP. The transformations are represented in the system as programs in the Q L I S P language, and are summoned by pattern-directed funct ion invocations. The synthesis of two programs produced by the system are presented. This research was supported in part by the Advanced Research Projects Agency of the Department of Defense under Contract MDA90176-C-0206, by the National Science Foundation under Grant DCK72-03737 A0\, by the Office of Naval Research under Contracts A/00014-76-C-06S7 and A/000 M-75-C-08I6; and by a grant from the United States-Israel Binational Science Foundation (BSF), Jerusalem, Israel. The views and conclusions contained in this document are those of the authors and should not be interpreted as necessarily representing the official policies, either expressed or implied, of Stanford University, Stanford Research Institute, or the U.S. Government. I . I n t r o d u c t i o n Jn this paper we describe a system that attempts to construct a program to meet given specifications. The system, called SYNSYS, accepts specifications expressed in a high-level mathematical notation and produces recursive, side-effect-free L ISP programs. The basic approach is to find a sequence of transformations which, when applied successively to the output specification, yield a sequence of equivalent descriptions leading to the desired program. A u t o . Pro RICHARD W A L D I N C E R Ar t i f i c ia l Intelligence Center Stanford Research Inst i tute Menlo Park, Ca. The SYNSYS system has been partially described in an earlier paper (Manna and Waldinger [1977]). In that discussion we emphasized the mechanisms for introducing conditional expressions and recursion into the program being produced. The exposition in this paper is self-contained, but our principal concern here wil l be the formation of systems of recursive programs The earlier paper also contained a more complete description of the SYNSYS implementation. The transformation rules of the system are written in QLISP (Wilber [1976]), an extension of I N T E R L I S P with pattern-directed function invocation and backtracking. The two examples we present have been performed automatically by SYNSYS. In Section II we describe our basic approach. We then (Section 111) present the first example, the synthesis of the Euclidean algorithm. Section IV provides a discussion of the method for introducing auxill iary functions, which is then illustrated by the construction of a two-function system for computing Cartesian products (Section V). A final section outlines some of the system's limitations, and our future research plans. I I . B a s i o A p p r o a c h There are many constructs that are valuable in expressing the specifications of a program, but that are not likely to appear as features in a programming language. For example, in specifying a program to compute the greatest common divisor of two integers x and y, we provide the input specification x z 0 and y z 0 and {x * 0 or y * 0 ) , and the output specification gcd(x y) <max{z : z\x and z\y) . The output specification requires that we find the greatest integer that divides both x and y. The input specification states that we can expect both arguments to be nonnegative and at least one to be nonzero; if both x and y are zero, the output specification is not defined. The set constructor {z : ...J is a valuable aid in expressing the output specification, but it is not a pr imi t ive construct in most programming languages because it is not always computable. Similarly, to specify the program to find the maximum element of a list of numbers, we may supply the input specification