data types; if it is a kind, the instances of abstract types are second-class values, as it happens in most module systems. Eliminating the distinctions between types and kinds through Type:Type, also indirectly confuses the distinctions between values and types. For example consider the program f = fun(A:Type) fun(x:A) x, and try and answer the question "is x a value?", or "is the result of f a value?". This cannot be determined, because the following applications are both legal: f(Integer)(3) and f(Type)(Integer). This mixing of value and type levels becomes a considerable obstacle when considering compiled languages, or languages extended with imperative features, which must make a clear distinction between compile-time and run-time phases. In such cases, one should at least make a proper distinction between types and kinds, or otherwise stratify the system in order to eliminate Type:Type. Unfortunately, the confusion between compile-time and run-time phases can be caused by dependent types alone, even without Type:Type. This is because of the All Elimination rule, where B{x‚Üêa} requires an arbitrary term (possibly a run-time value) to be substituted inside a (compile-time) type.