<i>Range selection</i> is the problem of preprocessing an input array <i>A</i> of <i>n</i> unique integers, such that given a query (<i>i, j, k</i>), one can report the <i>k</i>'th smallest integer in the subarray <i>A</i>[<i>i</i>], <i>A</i>[<i>i</i> + 1],..., <i>A</i>[<i>j</i>]. In this paper we consider static data structures in the word-RAM for range selection and several natural special cases thereof.
 The first special case is known as <i>range median</i>, which arises when <i>k</i> is fixed to ⌊(<i>j -- i</i> + 1)/2⌋. The second case, denoted <i>prefix selection</i>, arises when <i>i</i> is fixed to 0. Finally, we also consider the <i>bounded rank prefix selection</i> problem and the <i>fixed rank range selection</i> problem. In the former, data structures must support prefix selection queries under the assumption that <i>k</i> ≤ κ for some value κ ≤ <i>n</i> given at construction time, while in the latter, data structures must support range selection queries where <i>k</i> is fixed beforehand for all queries. We prove cell probe lower bounds for range selection, prefix selection and range median, stating that any data structure that uses <i>S</i> words of space needs Ω(log <i>n</i>/log(<i>Sw/n</i>)) time to answer a query. In particular, any data structure that uses <i>n</i>log<sup><i>O</i>(1)</sup> <i>n</i> space needs Ω(log <i>n</i>/log log <i>n</i>) time to answer a query, and any data structure that supports queries in constant time, needs <i>n</i><sup>1+Ω(1)</sup> space. For data structures that uses <i>n</i> log<sup><i>O</i>(1)</sup> <i>n</i> space this matches the best known upper bound.
 Additionally, we present a linear space data structure that supports range selection queries in <i>O</i>(log <i>k</i>/log log <i>n</i> + log log <i>n</i>) time. Finally, we prove that any data structure that uses <i>S</i> space, needs Ω(log κ/log(<i>Sw/n</i>)) time to answer a bounded rank prefix selection query and Ω(log <i>k</i>/log(<i>Sw/n</i>)) time to answer a fixed rank range selection query. This shows that our data structure is optimal except for small values of <i>k</i>.