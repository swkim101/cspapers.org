In large-scale multiprocessors, whether loosely or tightly coupled, some memory is cheaper to access than other memory. Because direct management of memory on these machines is quite burdensome to the programmer, much research effort has been directed toward providing a shared virtual memory (SVM) interface. Clearly, the success of this endeavor depends heavily on the efficiency of page management strategies. To date, this has been primarily the responsibility of the operating system, and secondarily that of the hardware. Unfortunately, delaying page management decisions entirely until run time can lead to an unacceptable loss of efficiency, due to poor data layout and memory reference patterns that are fixed by the end of compile time. For this reason, programmer assistance has been occasionally solicited. However, this disrupts the SVM abstraction. Moreover, many of these problems may be addressable at the compiler level instead. This is especially promising for array-based languages where compiler-based, analytical technology is most mature. Surprisingly, this possibility is largely unexplored. In this paper, we discuss the issue of compiler involvement in areas ranging from loop transformations and scheduling issues, to data layout strategies, page placement decisions, access pattern analysis, and use of run time system directives.