In this paper, we consider the following inverse maintenance problem: given A ∈ R<sup>n×d</sup> and a number of rounds r, at round k, we receive a n x n diagonal matrix D<sup>(k)</sup> and we wish to maintain an efficient linear system solver for A<sup>T</sup>D<sup>(k)</sup>A under the assumption D<sup>(k)</sup> does not change too rapidly. This inverse maintenance problem is the computational bottleneck in solving multiple optimization problems. We show how to solve this problem with Õ (nnz(A) + d<sup>ω</sup>) preprocessing time and amortized Õ(nnz(A) + d<sup>2</sup>) time per round, improving upon previous running times. Consequently, we obtain the fastest known running times for solving multiple problems including, linear programming and computing a rounding of a polytope. In particular given a feasible point in a linear program with n variables, d constraints, and constraint matrix A ∈ R<sup>d×n</sup>, we show how to solve the linear program in time Õ((nnz(A) + d<sup>2</sup>)√ d log(∈<sup>-1</sup>)). We achieve our results through a novel combination of classic numerical techniques of low rank update, preconditioning, and fast matrix multiplication as well as recent work on subspace embeddings and spectral sparsification that we hope will be of independent interest.