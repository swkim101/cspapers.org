In most designs of SDN scenarios, there is only one flow table in each switch, e.g. OpenFlow 1.0. Even with the adoption of multiple flow tables in later versions of OpenFlow, this feature is still not widely used. In the current design of OpenFlow, a controller has two ways to get the view of a flow: 1) the controller passively learns a flow if the flow is mismatched in the flow table; 2) the controller proactively pulls the counters of each rule. If only one flow table is used, whether the controller can see a flow is wholly determined by the flow table, i.e. the visibility is coupled to the operability. However, the coupling has the following problems: 1. Invisible flows. The first packet of the flows may be required by some applications to learn the flows, but gets lost due to the limitation of the design. For example (Figure 1(a)), a wildcard rule installed by a forwarding application will mask all the matched micro-flows which should be visible to a firewall application. To ensure every micro-flow can be seen by the controller, Frenetic [2] installs an exact-match rule after each micro-flowâ€™s arrival instead of installing wildcard rules in advance, while introducing significant latency in forwarding. 2. Unnecessary visibility. The visibility of a part of flows may be unnecessary to any of the applications, but it is provided with extra resource cost or network performance degradation. For example (Figure 1(b)), whenever a load-balance application queries elephant flows from the flow table, all the mice flows are also unnecessarily got[1]. 3. Rule explosion. Applications may query the counters of the flows, and the queries should be composed with the forwarding policy. However, the composition may cause rule explosion. For example (Figure 1(c)), in a single switch network where the forwarding behavior are only depend on the dstIP, the monitor wants to get the statistics from each srcIP. Separately, The number of rules needed by the forwarding APP and the monitor APP is respective O(n) and