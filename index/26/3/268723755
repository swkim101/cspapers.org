The decades-old Pattern Matching with Edits problem, given a length-n string T (the text), a length-m string P (the pattern), and a positive integer k (the threshold), asks to list all fragments of T that are at edit distance at most k from P. The one-way communication complexity of this problem is the minimum amount of space needed to encode the answer so that it can be retrieved without accessing the input strings P and T. The closely related Pattern Matching with Mismatches problem (defined in terms of the Hamming distance instead of the edit distance) is already well understood from the communication complexity perspective: Clifford, Kociumaka, and Porat [SODA 2019] proved that Ω(n/m · k log(m/k)) bits are necessary and O(n/m · klog(m|Σ|/k)) bits are sufficient; the upper bound allows encoding not only the occurrences of P in T with at most k mismatches but also the substitutions needed to make each k-mismatch occurrence exact. Despite recent improvements in the running time [Charalampopoulos, Kociumaka, and Wellnitz; FOCS 2020 and 2022], the communication complexity of Pattern Matching with Edits remained unexplored, with a lower bound of Ω(n/m · klog(m/k)) bits and an upper bound of O(n/m · k3logm) bits stemming from previous research. In this work, we prove an upper bound of O(n/m · k log2 m) bits, thus establishing the optimal communication complexity up to logarithmic factors. We also show that O(n/m · k logm log(m|Σ|)) bits allow encoding, for each k-error occurrence of P in T, the shortest sequence of edits needed to make the occurrence exact. Our result further emphasizes the close relationship between Pattern Matching with Mismatches and Pattern Matching with Edits. We leverage the techniques behind our new result on the communication complexity to obtain quantum algorithms for Pattern Matching with Edits: we demonstrate a quantum algorithm that uses O(n1+o(1)/m · √km) queries and O(n1+o(1)/m · (√km + k3.5)) quantum time. Moreover, when determining the existence of at least one occurrence, the algorithm uses O(√n1+o(1)/m · √km) queries and O(√n1+o(1)/m · (√km + k3.5)) time. For both cases, we establish corresponding lower bounds to demonstrate that the query complexity is optimal up to sub-polynomial factors.