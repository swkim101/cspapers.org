Overview The Texas persistent store is a portable and efficient system providing persistence and huge address spaces for C++. Texas uses pointer swizzling at page fault time to translate addresses from a long (" persistent ") format to the actual hardware-supported format, using virtual memory access protections to shield the program from ever encountering untranslated pointers. Pointer swizzling at page fault time provides performance comparable to a normal demand-paged virtual memory, and makes the implementation surprisingly simple-Texas is only a few thousand lines of code, running on unmodified SVR4 Unix and ULTRIX, and it is compatible with most existing C++ compilers. Texas is freely available and may easily be included in application programs. 1 Background Persisfent programming languages allow programmers to avoid saving data to files, and instead to simply make heap data persist from one run of a program to another. That is, rather than explicit translation, objects from a pointer-linked heap format to a low-level file data representation, they may be transparently flushed out to disk intact. This avoids the loss of pointer semantics (i.e., object identity) which typically, follows from conventional l/O. Persistent programming languages free programmers from this burden, but they require special implementation techniques to allow the use of a very large pointer-linked heap in place of most file operations. Persistent heaps may be very large, because all of the objects in a large system may be addressed individually, rather than being separated into files. Checkpointing and recovery are essential, to avoid the corruption of file-like data in the face of crashes. We use pointer swizzling at page fault time to address huge amounts of data without incurring continual runtime costs; we are also implementing log-structured storage and sub-page logging to keep checkpointing costs low. Huge address spaces require long pointers, but most hardware does not directly support them. For high performance systems, it is desirable that most pointers be represented in the actual hardware address format. Pointer swizzling systems convert pointers from a long representation into actual hardware addresses as needed. Conventional pointer swizzling systems incur significant overhead, however, because each pointer access requires a check to see if it has been swizzled yet. This checking cost reduces the efficiency of programs and complicates the implementation of the language-the compiler