Before we can assess the roles and values of AI and the tools of logic in the domain of software we must be sure that we appreciate the nature of this domain. Unfortunately there is a great deal of truth to the statement “software is to the computer as life is to the planet”. Thus we know that there are many kinds of software created in many kinds of ways and serving myriad purposes. We can appreciate some of the key issues of life by examining the human being but not, in a completely satisfactory way, by examining his tools. his tools. To understand software we must go beyond the techniques and methodologies we have so carefully and painfully crafted, e.g., high level languages, structured programming, data structures and types, semaphores, functional programming, etc. Adding a few more tools will not change things very much and will probably not tell us much about why software is the way it is.
Our dissatisfaction with software surfaced with operating systems and their offspring. Why? I think it was because they were created to provide an open set of services from a pool of loosely cooperating functions. Furthermore the set of services and the pool of functions would not tolerate a bound in number, intricacy of communication, and efficiency of computer use. I believe that the word “software” obscures the issues that dominate our concerns and I choose the word “organithm” to identify that class of programs we study in software engineering. Operating systems are the archetype organithms. Paraphrasing Bernal, an organithm is a partial, continuous, progressive, multiform, and conditionally interactive realization of the potentiality of human thought expressed as computer program. Thought, being what it is, an organithm is a large collection of other perhaps more limiting programs held together by useful traffic patterns. While we may say that some of the parts are perfect for their purpose, the collection is never more than adequate and thus always in a state of evolution. Supporting this evolution is the major goal of software engineering. Put another way, the dynamics of organithm development set the locus of the concerns of software engineering.
Organithms model mental abstractions. As models they are approximations and never have enough state to serve as “uniform” approximants. Mental abstractions thrive on deduction and induction to increase their set of accessible states and sooner or later, like the interpolants they are, they turn sour and must change, often in unanticipated ways, in order to remain of use. So it is with the organithms that model them: Organithms are not maintained, they are reared. Like living matter they are continual consumers of energy and continual producers of waste. The creation of an organithm implies the support and act of husbandry. Thus research in the processes of organithm husbandry is, and has been, a vital concern of software engineering. Since organithms compete in their own biosphere—the computer—improvement in performance is eternally sought and, as a result, most of an organithm's state is concerned with the management of its own internals: As an organithm develops, an ever increasing concern of its logic is its own internal management and significantly, a smaller fraction of its logic is devoted to serving its external utility. Organithms tend to take advantage of their own purposes: As they develop, the internal functions of an organithm tend to maximize their use of the external functions the organithm exists to supply-this has been called closing the loop. Often these internal uses intensify traffic to such a degree that organithms are created to manage the use of the external functions, e.g., a mail system must be capable of supporting organithms that generate and read mail. Every external purpose of an organithm can be replaced by an organithmic surrogate.
Since organithms are models it takes little modification for them to model unanticipated abstractions. In the course of their development organithms suggest abstractions that are both valuable and that they can support. Organithms fuel the expansion of abstract modeling as a technological activity.
Unlike life, in which reproduction dominates mutation, our organithms are so simple that mutation still dominates reproduction, but this will change. A major role of AI and logic is to help in the creation of organithms that increasingly extricate us from direct involvement in the internal growth of organithms. The major issue of software engineering environments is not how to ease our task of programming systems but how to accelerate the rate at which improvement in internal function can be obtained without unduly jeopardizing the external functions of an organithm and with maximizing the use of organithms to perform reorganization. Insofar as AI and logic support autonomy in these activities of development and response will they be of value in the software enterprise.