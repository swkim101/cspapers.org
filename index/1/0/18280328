We consider the efficient implementation of the bottom-up evaluation method for recursive queries in logic databases. In the bottom-up evaluation algorithms the non-mutually-recursive rules are evaluated in certain order, whereas the evaluation order within a set of the mutually recursive rules is free. However, significant savings in join operations can be achieved by arranging the mutually recursive rules appropriately. We present an algorithm for splitting the evaluation loop for mutually recursive rules into subloops and for determining the order in which the rules should be evaluated within a loop. The seminaive evaluation algorithm is modified accordingly to gain advantage from the evaluation order and to work with the incremental relations (“deltas”) appearing at different levels in the loop structure. The computation within a subloop is optimized by identifying loopinvariant factors in the rules to be evaluated. Using an experimental logic database system we demonstrate the usefulness of our algorithm in implementing datalog queries optimized by the “magic sets” and related term rewriting strategies. *The work was supported by the Academy of Finland. Permission to copy without fee all or part of this material i\ granted provided that the copies are not made or distributed for direct commercial advantage. the VLDB copyright notice and the title of the publication and its date appear. and notice is given that copying is by permission of the Very Large Data Bnse Endowment. To copy otherwise. or to rcpuhlish. require> ;I fee and/or special permission from the Endowment. Proceedings of the 16th VLDB Conference Brisbane. Australia 1990 1. Introduct ion Recursive data base queries expressed in datalog (function-free Horn clause programs) are most conveniently evaluated using the bottom-up (or forward chaining) evaluation method (see, e.g., [l, 2, 5, 141). As the basic “naive” or “semi-naive” bottom-up method becomes inefficient when the query contains bound arguments, the usual approach is to preprocess the original query by means of some term rewriting strategy so that the bindings in the query literal can be used to restrict the set of database facts consulted [3,4,6]. Recently, it has been shown that it is possible to rewrite any safe datalog program as an equivalent datalog program so that the semi-naive bottom-up evaluation of the rewritten program is as efficient as the top-down evaluation of the original program [16]. The structure of the naive and semi-naive evaluation algorithm is determined by the “rule-goal graph”, which represents the dependencies between the predicates and rules in the datalog program to be evaluated [13, 41. The strongly connected components of this graph represent the maximal sets of mutually recursive predicates and rules. For each such component, the naive evaluation algorithm contains a loop that computes the values for the predicates in that component. The execution order between the loops is determined by the partial order between the strongly connected components, so that first comes the loop that implements the component whose predicates do not depend on predicates in the other components [13, 10, 7, 8,4]. The values of the predicates within a component are computed in an incremental fashion: at each iteration every rule whose head and body contains a predicate belonging to the component is used to add data to the current value of the predicate in the head of the rule. The relations for the predicates are ini-