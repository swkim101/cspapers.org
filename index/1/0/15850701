Traditional methods of teaching software engineering at the undergraduate and graduate levels lack full effectiveness due to the method of organization of the courses and compressed time schedules. This paper presents a studio approach to teaching large-scale, quality sof~are development that uses the technique of reflective practice in a highly interactive learning environment over a sixteen-month period. The results of a prototype offering of this course are described and analyzed. There is an accelerating proliferation of courses and degree programs in software engineering. Many of these programs define the difference between what they are trying to teach and what traditional computer science degree programs try to teach in terms of the differences between the methods and techniques of programming-in-the-small versus those of programming-in-theIarge. Unfortunately, academic environments do not lend themselves to support the development of truly large software products. The strict quarter or semester system limits the duration of a project. The credh hour concept limits the time students have to interact with each other in any given day or week. Although attempts have been made to lessen the impact of these time restrictions, they are more hopeful than helpful. In addition to time limitations, there are other weaknesses in current courses and programs that reduce the quality of the education of future software engineers. For instance, the common “built it and graduate” approach severely reduces the ability of the students to evaIuate their work as opposed to merely performing it. The Software Development Studio in the Carnegie Mellon Master of Software Engineering program addresses these problems by embedding the students’ production work throughout the entire 16-month curriculum and by using highly interactive teaching techniques. This paper first describes the nature of typical current software development courses, then presents the philosophy that underlies the Studio, and finishes by recounting a prototype offering that resulted in significant lessons. Shortcomings of Present Software Engineering Courses There are currently three basic types of courses that teach people how to develop computer software. Each, as with any academic Permission to copy without fee all or part of this material is granted provided that the copies are not made or distributed for direct commercial advantage, the ACM copyright notice and the title of the publication and its date appear, and notice is given that copying is by permission of the Association for Computing Machinery. To copy otherwise, or to republish, requires a fee and/or specific permission. @ 1991 ACM 0-89791-377-9/91 /0002-0300 . ..$1 .50 300 course, has its strengths and weaknesses. Unfortunately. in this case, the weaknesse;perpetuate the lack of skills most ;eeded to support large-scale software construction. Undergraduate Computer Science Courses For most future software engineers, their first contact with programming on a formal basis is the introductory course taken at either the secondary school or college level. This course usually is closely tied to a programming language such as Pascal or Ada. Though there are excellent instructors for this sort of course in many places, the simple fact is that these courses generally have the effect of teaching that software development is Ianguagecentered, that software is built to be thrown away, and that software can usually be developed and understood by one person. Later courses in the undergraduate computer science curriculum do little to dispel these notions. Though there are innovative instructors who team students in the occasional operating systems course, the majority of the computer science majors in the U.S. follow the same lonely, competitive trail from matriculation to graduation that their brothers and sisters in the liberal arts and sciences trod. Here the weaknesses lie in the emphasis on the production of miniature software, and the solitary nature of programming. One or Two Semester Project Courses Due to the boom in the teaching of software engineering, a number of schools are introducing one or two semester software development courses that require teams to actually build something. I have described the different models of these courses in Tomayko87. Here it is only necessary to recount that even these courses often fall short by concentrating on small teams and instructor-supplied requirements. Few use configuration management or any quality assurance techniques, let alone concepts from software engineering economics. Even those versions which organize the entire class as one large team producing software for an external customer still fail to get beyond “throw away” mode. There is barely enough time to build the software and deliver it, let a[one evaluate properly the process and product, and to learn how to maintain software.