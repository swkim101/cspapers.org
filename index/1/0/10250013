In our opinion, high-performance computing is plagued by two main problems. First, the main users of various high-performance applications are experts in their respective fields (physicists, chemists, biologists, and many other fields other than computer science) and they are solving problems in domains largely unrelated to the computing field. Yet, they are typically forced to work with low-level general purpose programming languages designed for ease of translation rather than ease of modeling. Consequently, productivity is low and many promising new techniques never see the light of day because it is simply too costly and difficult to integrate them into existing code-bases. Second, even though high-performance applications are developed at a low level, the additional performance tuning required to make the code run efficiently on new and evolving platforms is a time consuming process—the theoretical performance of a new platform is rarely (if ever) achieved and manually tuning the code to get close is very difficult. Thus, we see two main problems; (1) the lack of domain specific languages and domain specific language features suitable for the scientific and high-performance modeling tasks at hand and (2) the lack of a highly flexible and efficient translation infrastructure that will allow us to rapidly modify a compiler to take advantage of characteristics of the problem domain as well as the target hardware. To address both of these problems, we hypothesize that an extensible language implemented using attribute grammars with forwarding [13] can serve as a host-language for a plethora of domain specific language-extensions. There are two primary ways in which we can use such language extensions to create an extended-language. First, such extension can be combined to construct new domain specific modeling-languages suitable for different audiences and domains with high-performance computing needs. In this case, the programs written in the extended-language use only the high-level constructs introduced by the language extensions. These languages are similar to domain specific languages. A second way to use language extensions is to use them more sparingly in that programs written in the extended-language use many constructs from the underlying host-language as well as construct defined by the language extensions. In this case, the programs are typically recognizable as programs written in the host-language with the exception that there are additional domain specific constructs being used. The attribute grammar based compilers for such languages can be seen as “pre-processors” that compile the language extension features down to their representation in the host language. A traditional compiler can then be used to translate the resulting code to machine code. Extensible languages based on attribute grammars and forwarding can also serve as a framework for the translation of these extension constructs into their semanticallyequivalent representation in the host-language and the hostlanguage translation to various hardware architectures.