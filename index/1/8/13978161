Many classical compiler optimizations can be elegantly expressed using rewrite rules of form: <i>I</i> ⇒ <i>I</i>′ if <i>&phis;</i>, where <i>I</i>, <i>I</i>′ are intermediate language instructions and <i>&phis;</i> is a property expressed in a temporal logic suitable for describing program data flow. Its reading: If the current program π contains an instruction of form <i>I</i> at some control point <i>p</i>, and if flow condition <i>&phis;</i> is satisfied at <i>p</i>, then replace <i>I</i> by <i>I</i>′.The purpose of this paper is to show how such transformations may be proven correct. Our methodology is illustrated by three familiar optimizations, dead code elimination, constant folding and code motion. The meaning of correctness is that for any program π, if <i>Rewrite</i>(π, π′, <i>p</i>,<i>I</i> ⇒ <i>I</i>′ if &phis;) then [[π]] = [[π′]], i.e. π and π′ have exactly the same semantics.