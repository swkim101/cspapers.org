We consider two hashing models for storing a set <italic>S</italic> ⊂ {0, 1, 2, …, <italic>m</italic> - 1} in a table <italic>T</italic> of size <italic>n</italic>.
The first model uses universal hashing for a partially loaded table. A set of hash functions is universal if, for any the input set, a randomly selected function has an efficient expected performance. Universal hash functions originate in [CW79], where they were used for open hashing using chaining. [CW79] poses as an open question whether comparable results can be achieved for any closed hashing schemes.
The second model is perfect hashing for a full table. In preprocessing the input set is used to determine a hash function that achieves some desired performance criteria. This model was used among others in [ME82] and [FKS84].
In both models a key problem is to construct a “small” set of functions, which will permit a short description (program) for each function in the set.
<list><item>We show, for the first time, that universal hashing can be successfully used for closed hashing and in particular for double hashing. Specifically, the set of congruential polynomials of <italic>&Ogr;</italic>(log <italic>n</italic>) degree is universal for double hashing if the table load is below .75; the program size (or number of random bits generated by the algorithm) is <italic>&Ogr;</italic>(log log <italic>m</italic> + log<supscrpt>2</supscrpt> <italic>n</italic>).
</item></list>For perfect hashing, we obtain nearly tight results on the size of oblivious <italic>&Ogr;</italic>(1)-probe hash functions:<list><item>Oblivious <italic>k</italic>-probe hash functions require &OHgr;(<italic>n</italic>/<italic>k</italic><supscrpt>2</supscrpt><italic>e</italic><supscrpt>-<italic>k</italic></supscrpt> + log log <italic>m</italic>) bits of description.
</item><item>A probabilistic construction is presented, which shows that oblivious <italic>k</italic>-probe hash functions, can be specified in <italic>&Ogr;</italic>(<italic>ne</italic><supscrpt>-<italic>k</italic></supscrpt> + log log <italic>m</italic>) bits, which nearly matches the above lower bound.
</item><item>We give a variation of an <italic>&Ogr;</italic>(1) time 1-probe (perfect) hash function that can be specified in <italic>&Ogr;</italic>(<italic>n</italic> + log log <italic>m</italic>) bits, which is tight to within a constant factor of the lower bound.
</item></list>
In view of the adaptive schemes presented in [FNSS88], these bounds establish a significant gap between oblivious and non-oblivious <italic>&Ogr;</italic>(1)-probe search.