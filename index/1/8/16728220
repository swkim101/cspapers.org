1 I n t r o d u c t i o n Sorting is the canonical information-processing application. It accounts for roughly 20-25 percent of the computing resources on large-scale computers [8,9]. In most applications the file of records cannot fit into internal memory and must be stored on (external) sec* S u p p o r t was p rov ided in pa r t by an NSF Pres iden t i a l Young Inves t iga to r Award C C R 8 9 0 6 4 1 9 wi th m a t c h i n g f u n d s f rom IBM, by NSF resea rch g r a n t D C R 8 4 0 3 6 1 3 , a n d by O N R g ran t N 0 0 0 1 4 8 3 K 0 1 4 6 , A R P A Orde r No. 4786. t T h i s work was done in pa r t while t he a u t h o r was a t Brown Univers i ty a n d s u p p o r t e d by a Bellcore g r a d u a t e fellowship. Permission to copy without fee all or part of this matertial is granted provided that the copies are not made or distributed for direct commercial advantage, the ACM copyright notice and the title of the publication and its date appear, and notice is given that copying is by permission of the Association for Computing Machinery. To copy otherwise, or to republish, requires a fee and/or specific permission. ondary storage, usually in the form of magnetic or optical disks. Sorting in this framework is called ezternal sorting. The bottleneck in external sorting and many other applications is the time for the input /output (I/O) between internal memory and the disks. This bottleneck is accentuated as processors get faster and parallel computers are used. One remedy is to use secondary storage systems with parallel capabilities. Previous work on I /O efficiency has concentrated on two-level and multilevel models. (Further references can be found in the papers mentioned below.) Aggarwal and Vitter [3] present optimal upper and lower bounds for sorting-related problems using a two-level memory model in which P blocks, each consisting of B contiguous records, can be transferred simultaneously in a single I/O. Their model is somewhat unrealistic, however, because secondary storage is usually partitioned into separate physical devices, each capable of transferring only one block per I/O. Multilevel hierarchical memory models are introduced in [1,2], one of them taking into account block transfer. Access to a location z takes time f(z), and in the blocking version, access to successive locations takes one unit of time per location. Optimal bounds are obtained for several problems. Parallel transfer using several hierarchies simultaneously was not considered in [1,2]. In this paper we are interested in optimal algorithms for powerful two-level and hierarchical memory models that allow P simultaneous transfers of data. To be realistic, we require that each block transfer must access a separate secondary storage device. In Section 3 we define a realistic two-level memory model with parallel block transfer, and we state our main results, which give tight upper and lower bounds on the number of I /Os needed to solve several important problems. The problems, which include sorting, permuting, matrix transposition, FFT, permutation networks, and standard matrix multiplication, are defined in Section 2. The two-level model correÂ© 1990 ACM 089791-361-2/90/0005/0159 $1.50 159 sponds to having an internal memory and P disks, each capable of simultaneously transferring one block of B records. Our measure of performance is the number of parallel I /Os required; this ignores internal computation time, but the internal processing done by our algorithms is simple enough so that in practice it can be overlapped with the I /O time. Our algorithms can be significantly faster than those obtained by the wellknown technique of disk striping. The restriction that only one block can be accessed per disk during an I /O is what distinguishes our model from the less realistic model of [3]. This distinction is akin to the difference in parallel computation between the more realistic MPC (module parallel computer) model and the less realistic PRAM model. The algorithms we develop on our more realistic model use the same number of I /Os as those in [3] for the less realistic model. In Section 4 we define two uniform memory models, each consisting of P hierarchical memories connected together at their base levels. The P hierarchical memories are of the type discussed in [1,2]. We give optimal time bounds for the problems in each model. Sections 5-7 are devoted to the algorithms and analysis for the two-level model. In Section 5 we develop optimal algorithms for matrix transposition, FFT, and permutation networks, by making use of the shuffle-merge primitive. Even though these problems are sorting-related, it is much easier to develop optimal algorithms for them than it is for sorting, since their I /O schedules are nonadaptive. Our main result is the optimal randomized algorithm for sorting (and permuting) and its probabilistic analysis in Section 6. The probability that it uses more than ~ times the optimal number of I /Os is exponentially small in ~(logt)log(M/B), where i is the internal memory size. The sorting algorithm is a variant of distribution sort; a combination of two interesting randomized techniques is used to do the partitioning so as to take full advantage of parallel block transfer. In Section 7 we cover standard matrix multiplication. In Section 8 we show how to apply the algorithms developed for the two-level model to get optimal algorithms for the hierarchical models. The hierarchical algorithms are optimal because the internal processing in the corresponding two-level algorithms is efficient. For simplicity of notation, we use logx, where x >__ 1, to denote the quantity max{l , log 2 x}. We also assume for the most part that the numbers we deal with are integers and divide evenly, so as not to clutter up the manuscript with numerous floors and ceilings. On the other hand, there are some places in the analysis where this issue is important , so we will be more precise in those cases. The complete set of results and the full proofs appear in the full version of this paper [15]. 2 P r o b l e m Def ini t ions The sorting problem consists of rearranging the N records so that their key values are in nondecreasing order. The permuting problem is the special case of sorting in which the key values of the N records are distinct integers in {1, 2, . . . , N}. Matrix transposition is the special case of permuting in which the permutation to be realized corresponds to matr ix transposition. The FFT problem can be phrased as the problem of pumping the records into and out of internal memory so as to permit the computation implied by the FFT digraph. The permutation network problem is like the FFT problem, except that a comparator network capable of realizing any permutation is used instead of the FFT digraph. There is an important difference between permutation networks and general permuting. In the latter case, the particular I /Os performed may depend upon the desired permutation, whereas with permutation networks all N! permutations can be generated by the same sequence of I/Os. The standard matrix multiplication problem deals with computing the product C = A x B of two k x k matrices, by following the well-known algorithm that uses O(k 3) additions and multiplications. The elements of A, B, and C are assumed to be in row-major order. 3 Two-Leve l M e m o r y M o d e l First we define the parameters for our two-level memory model (or disk model) with parallel block transfer: Def in i t i on 1 The parameters are defined by N = ~ records in the file; M = # records that can fit in internal memory; B = ~ records per block;