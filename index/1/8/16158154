Use of strictness analysis in parallel evaluation and optimization of lazy functional languages is well known. The first formal treatment of strictness analysis appeared in Mycroft's seminal work which however dealt only with flat domains. Unlike flat domains, strictness analysis on non-flat domains involves determining how a function transforms a demand (degree of strictness) on its output into a demand on its arguments. Solutions to this problem in its full generality require large domains and appear both complex and expensive to implement. However, only two kinds of demands arise naturally in lazy normalization of terms, viz., <italic>e</italic>-demand (normal form needed) and <italic>d</italic>-demand (root stable or head normal form needed). Based on this observation, we identify three useful forms of strictness for non-flat domains - <italic>ee</italic>, <italic>dd</italic> and <italic>de</italic>. Each of these three forms of strictness play an important role in evaluation of functional programs. Specifically, <italic>ee</italic> strictness is used for transforming call-by-need to call-by-value and <italic>dd</italic> strictness is useful in repairing violations of <italic>strong sequentiality</italic> of equational programs as well as in a critical optimization step used in rewriting implementations of such languages. We present intuitively simple methods to compute them. Our methods are computationally efficient as they are based on small domains (1 point for <italic>ee</italic> and <italic>dd</italic> and 2 points for <italic>de</italic>). They are powerful enough to extract all useful strictness information in practice and are general enough to handle functions defined by rewrite rules. We are able to reason about all user defined data types within a single framework and also handle polymorphism.