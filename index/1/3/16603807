In this paper, an object-based approach to protocol software implementation is presented. A protocol is specified by an FSM, then the FSM is implemented by a group of related objects. In our method, each state is implemented by an object. The member functions of an object are the interface vents that trigger state transitions, and actions associated with state transitions constitute the body of the member functions. An object becomes another object if a state transition is enabled. A real example is given for illustration. We also present a software tool that lets a designer edit a state machine graphically, and generates C++ class definitions automatically. We also discuss some implementation related issues and present an organization model for protocol layers.