CS2 is the second course in our computing major. Our intent in this course is to teach students to derive procedures for manipulating dynamic data structures such as lists and trees. We have recently changed our implement ation language from Pascal to OberonF. This allows us to encapsulate the abstract data structures and their operations into abstract data types. Oberon/F is a cross-platform compiler and runtime system which allows concurrent development for both Windows and the Macintosh operating system. This programming framework makes it possible to build applications which have the “look and feel” of the host operating system; that is, applications with dialog boxes, pulldown menus, etc. OberonF also allows type extension and type bound procedures, which provide a structured way to introduce inheritance and objects, respectively. Reusability of code is facilitated by a simple import/export mechanism, which is efficiently implemented by use of dynamic linking. The course begins with the introduction of proof rules for the procedure declaration and the procedure call, in the absence of recursion. These rules are used to derive algorithms for the abstract data type list as implemented in an array. These algorithms include deleting, sorting, loading, and storing. In addition, the searching algorithms derived in the first course are transformed into procedures. This part of the course culminates in a derivation of the Heapsort algorithm. After this, proof rules are given for the recursive procedure definition, which are then used to derive the Quicksort algorithm. Recursive procedures are used extensively in the derivation of algorithms for manipulating lists and trees with a linked implementation. This is quite natural given the recursive definition of these data structures. The derivations of these algorithms are very straightforward because the reappearance of a specification similar to the original (with different parameters) leads naturally to a recursive call. This unit includes a derivation of Mergesort on a linked list, and binary tree sort. A later section of this paper provides an example of such a derivation. The formulation of a specification from an informal description is a key step in program derivation. A programming task can of course be specified in many clifferent ways, and the choice of specification can effect both the ease of derivation and the efficiency of the final program. The students are taught to formulate specifications and explore alternatives.