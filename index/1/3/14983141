Today's complex computational and embedded systems compute complex quantities from complex inputs, with behavior dependent upon the (distributed) state of the system and its environment. Describing the intended behavior of such a system is challenging. The most natural and commonly used approach is to give a collection of scenarios, where each scenario is a sequence of inputs and expected outputs. An analyst elicits scenarios from subject matter experts (SMEs) to document functional requirements. Scenarios can be represented in a variety of ways, from informal narratives through (formal) linear event sequences. Formal behavior scenarios are useful in many software engineering tasks, including requirements engineering, specification- and architectural-modeling, and test generation. Uses in modeling include model inference, validation, and measuring resource usage and reliability. Finally, scenarios are useful in discovering and documenting gaps in specifications. Existing scenario-based tools and methodologies break down when scenarios grow large. Elicitation becomes impractical, as it requires the human to specify all the steps. Even assuming one can capture thousands or more of input events, it is problematic for the human to describe the correct expected outputs at each point of interest. Finally, even if one can capture all inputs and outputs, the complexity of such an artifact gives one little confidence that it represents desirable behavior in detail, as the risk of undetected errors grows at least linearly with the size. Finally, the behavior of systems described by large scale scenarios typically requires a large and complex set of them, which creates the added difficulty of assuring oneself of covering a "representative" subset of a huge space