This paper presents a mechanism for the arbitration of parallel requests to shared resources. This mechanism is the serialize, which may be described as a kind of protection mechanism, in that it prevents improper orders of access to a protected resource. The mechanism is a generalization and improvement of the monitor mechanism of Brinch-Hansen and Hoare.Serializers attempt to systematize and abstract desirable structural features of synchronization control structure into a coherent language construct. They represent an improvement in the modularity of synchronization over monitors in several respects. Monitors synchronize requests by providing a pair of operations for each request type [examples are STARTREAD/ENDREAD and STARTWRITE/ENDWRITE for the readers-writers problems]. Such a pair of operations must be used in a certain order for the synchronization to work properly, yet nothing in the monitors construct enforces this use. Serializers incorporate this structural aspect of synchronization in a unified mechanism to guarantee proper check-in and check-out. In scheduling access to a protected resource, it is often desired to wait in a queue for a certain condition before it continues execution. Monitors require that a process waiting in a queue will remain dormant forever, unless another process explicitly signals to the dormant process that it should continue. Serializers improve the modularity of synchronization by providing that the condition for resuming execution must be explicitly stated when a process enters a queue making it it unnecessary for processes to signal other processes. Each process determines for itself the conditions required for its further execution.The behavior of a serializer is defined using the actor message-passing model of computation. Different versions of the "readers-writers" problems are used to illustrate how the structure of a serializer corresponds in a natural way to the structure of the arbitration problem to be solved. The correspondence makes it easier to synthesize a scheduler from behavioral specifications and to verify that an implementation satisfies its specifications.No claim is made for the "completeness" of the serializer mechanism, beyond showing that semaphores can be implemented using serializers. Further, no "complete" solution is proposed to the "no-starvation" specification which requires that a resource reply to each request which it receives. Rather, it is shown for some simple examples that serializers represent a step toward better structuring of parallel access to shared resources, and that proofs that starvation is impossible for these examples are easier with serializers than with some of the currently existing mechanisms for controlling parallel access to resources.