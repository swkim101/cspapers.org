In many design applications, it is common practice to store corn-pfex hierarchical objects in a compactfolded form to save storage space and to reduce processing costs for accessing the objects. In these folded representations, complex objects are built up from identical and otherwise indistinguishable objects. Howevec it is o&en necessary, especially during the refinement of data, to distinguish between these identicul forCtd objects by personakkg a subset of them. The established practice is IO eqficitfy unfold the hierarchical objects and thus create space in which to store distinct personalization data for each object occurrence. However, this explicit unfolding is costly and time consuming, resulting in a potentiaZfy much larger structure, and substantially increasing the costs of querying and updating the design. Therefore, we propose an unfold operator that supports access to data in a virtua& Unfolded view. We describe how to updare customized values for each hierarchical sub-object through the unfolded view. We propose alternative strategies for the maintenance of personalization values, representing various portions of the view materialization spectrutn. We present a performance evaluation comparing these strategies as well as the traditional explicit unfolding approach. Our evaluation indicates the trade-ofi inn. terms of storage and query costs and compares the costs to do implicit unfolding Jhrough a view rather than explicit unfolding of compkx hierarchical objects. 1 Iutroductiou and Probiem Description Introduction. An increasing number of applications must be able to store, query, and retrieve complex hierarchical objects. Objects containing repeated subparts can be represented compactly by folding them along a part-of relationship, using multiple references to identical subparts instead of repIic%ing fiem. In the folded implementation occurrence paths represent distinct objects impIicitfy, rather than through explicit object instances. For example, Figure I(a) shows a stack of cubes cl and ~2, each containing 6 faces. The bottom face of cube cl is represented by the occurrence path cl: :bottam Similarly, each of the. 16 full-adders (FA) in the object of Figure l(b) exists as a path, e.g., a3 : : f 3. Folded hierarchical objects are a powerful construct used in many domains such as mechanical and electronic design, genome databases, and graphical applications. During the design process a user eventually requires an unfolded view of the data. While OODB systems can represent folded hierarchical structures, they do not explicitly model the semantics of the folding relationship. As a consequence the dataPermission to mike digilnliltnrd copies of‘3ll or pm1 olXis mnterirl lilr pasonal or cl:tssroom tse is grmt~vi wi~lmrt I& provided thn~ the copies are not IX& UT dirtrihulcd Ibr prulit or cormncrcinl ndvnntngedx copyright no!icc. tllc ti~lc orthe puhliczkon and ib &II~ :rppenr. and mtice is given llml copyright ix by pemk5iun ofthe ~\Ckl. Inc. ‘li, copy olhanviae. IO republish, to post on servem or to raiistrihtrtc IO lists. requires .sp&tic pcnnission andfor rec. CIKM 97 L0.Ce@xY .\kl’flI/il I :x4 Copy&$1 1997 ACbl O-89791~‘17Wi <J7. I l..S3.5ft 222 bases do not support defining implicitly unfolded database views, Software tools external to the database usually perform such unfoIding explicitly, creating a separate representation [IS], resulting in the many known probIems caused by redundant data rcplication. We have developed a hierarchical set model [12], called HierSet that addresses this problem by enabling a database view system to create an unfolded view of the folded structures lmpllcitly, without creating a separate representation. Our HIcrSct approach provides a framework within which to solve the personaliiation problem, as we will demonstrate in this paper.