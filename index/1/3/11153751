We investigate the importance of space when solving problems based on graph distance in the streaming model. In this model, the input graph is presented as a stream of edges in an arbitrary order. The main computational restriction of the model is that we have limited space and therefore cannot store all the streamed data; we are forced to make space-efficient summaries of the data as we go along. For a graph of <i>n</i> vertices and <i>m</i> edges, we show that testing many graph properties, including connectivity (<i>ergo</i> any reasonable decision problem about distances) and bipartiteness, requires Ω(<i>n</i>) bits of space. Given this, we then investigate how the power of the model increases as we relax our space restriction. Our main result is an efficient randomized algorithm that constructs a (2<i>t</i> + 1)-spanner in one pass. With high probability, it uses <i>O(t .n</i><sup>1+1/<i>t</i></sup> log<sup>2</sup><i>n</i>) bits of space and processes each edge in the stream in <i>O(t</i><sup>2</sup>·<i>n</i><sup>1/<i>t</i></sup> log <i>n</i>) time. We find approximations to diameter and girth via the constructed spanner. For <i>t</i> = Ω(log <i>n</i>/log log <i>n</i>), the space requirement of the algorithm is <i>O(n</i> .polylog <i>n</i>), and the per-edge processing time is <i>O</i>(polylog <i>n</i>). We also show a corresponding lower bound of <i>t</i> for the approximation ratio achievable when the space restriction is <i>O(t.n</i><sup>1+1/<i>t</i></sup> log<sup>2</sup><i>n</i>).We then consider the scenario in which we are allowed multiple passes over the input stream. Here, we investigate whether allowing these extra passes will compensate for a given space restriction. We show that finding vertices at distance <i>d</i> from a particular vertex will always take <i>d</i> passes, for all <i>d</i> ∈ {1,...,<i>t</i>/2}, when the space restriction is <i>o</i>(<i>n</i><sup>1+1/<i>t</i></sup>). For girth, we show the existence of a direct trade-off between space and passes in the form of a lower bound on the product of the space requirement and number of passes. Finally, we conclude with two general techniques for speeding up the per-edge computation time of streaming algorithms while increasing the space by at most a log factor.