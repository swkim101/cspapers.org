1. PROBLEM DESCRIPTION As programmers usually can hardly always produce faultless code in the first place, debugging is an inevitable task in the process of software development and maintenance. Actually, debugging has been identified as one of the most timeconsuming tasks [7]. The situation may become even worse when a developer or a maintainer has to face code written by others. Typically, there are mainly two steps in debugging: 1) finding the location of the fault, and 2) replacing the faulty statement(s) with the correct one(s). In the literature, four main tasks in the process of finding the location of the fault have been identified [7]: 1) identifying statements involved in failures; 2) narrowing the search by selecting suspicious statements that might contain faults; 3) hypothesizing about suspicious faults; and 4) restoring program variables to a specific state to verify the hypothesis. In practice, a developer usually focuses on one fault revealing execution, as it can often be assumed that there is at least a faulty statement along the execution trace. Usually, manual fault localization is an interactive process: The developer firstly hypothesizes that all the statements that involve in the execution are suspicious. Then, he or she sets some breakpoints along the fault revealing execution trace and re-runs the execution trace to gather information around the breakpoints. According to this information, he or she can further narrow down the scope of suspicious statements. The process is repeated until he or she finds where the fault is. To help human debugging, many approaches have been recently proposed to localize faults automatically (see e.g. [1] [2]