Deadlock-freedom is a major challenge in developing multi-threaded programs, as a deadlock cannot be resolved until one restarts the program (mostly by using manual intervention). To avoid the risk of blocking, a program may use the trylock operations rather than lock operations. In this case, if a thread fails to acquire a lock using trylock, since trylock is non-blocking, the thread can release acquired locks to avoid a deadlock after trylock returns. Although this approach avoids deadlocks, it may also introduce bugs such as livelock and deadlivelock. Moreover, when such bugs are identified in a program, revising the program manually is error-prone. 
 With this motivation, in this paper, we propose an approach for avoiding deadlocks, livelocks and deadlivelocks in the given multi-threaded program. In our approach, we first identify cyclic lock dependencies that may lead to deadlocks, livelocks or deadlivelocks. Subsequently, we map the problem of ensuring freedom from deadlocks, livelocks and deadlivelocks to the weighted partial maximum satisfiability problem. To ensure that the repaired program preserves most of original design, our approach attempts to make minimal changes to the original program.