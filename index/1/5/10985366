Binary constraint sat is fact ion problems involve f ind ing values for variables subject to constraints between pairs of variables. A lgo r i t hms that take advantage of the st ructure of constra int connections can be more efficient than simple backtrack search. Some pairs of variables may have no direct constraint between them, even if they are l inked ind i rect ly th rough a chain of constraints invo lv ing other variables. A set of variables w i t h no direct constraint between any pair of them forms a stable set in a constraint graph representat ion of a p rob lem. We describe an a lgo r i thm designed to take advantage of stable sets of variables, and give exper imenta l evidence that it can ou tpe r fo rm not only s imple back t rack ing, but also fo rward checking, one of the best var iants of backtrack search. Potent ia l appl icat ions to paral le l processing are noted. Some light is shed on the question of how and when a constraint sat isfact ion problem can be advantageously d iv ided into subproblems. 1 D I R E C T I N D E P E N D E N C E O F V A R I A B L E S Const ra in t sat isfact ion problems involve f inding values for va r i ables subject to constraints, or relat ions among the variables. Often these constra ints are restr icted to being b inary relat ions between two variables, we shall consider b inary constraints here. Standard backHack search can be used to solve such problems. In general the upper bound on the complex i ty of the search is exponent ia l in the number of variables In th is paper we propose tak ing advantage of the " re lat ive independence' of variables to amel iorate the search complex i ty . We te rm t w o var iables d i rect ly independent if there is no direct constraint, between t h e m , even if they may be ind i rect ly related by a chain of constraints passing th rough intermediate variables. The basic insight is i l lustrated by the example in Figure 1. The problem involves three variables, each w i t h three possible values, and a constraint graph (Figure l a , l b ) L inks in the graph represent const ra ints ; nodes represent variables Note that there is no direct constraint between variables y and z. If we approach the problem w i t h a s t ra igh t fo rward backt rack ing a lgo r i t hm, we might have to examine almost 3 x (3 x 3) or 27 possible t r ip les of values before h i t t i ng upon a solut ion in the r ightmost branch of the search tree. More than 27 tests on pairs of values would be performed (Figure ]c) . Now let. us take in to account the relat ive independence of variables y and z. Hav ing chosen a value for x, we can go ahead and choose a value for y and a value for z independent ly There w i l l be at most 6 values to consider (3 for each) before we succeed or fa i l If we fa i l , we repeat the process for the next x value. At most we w i l l per form 3x (3 + 3) or 18 tests on pairs of values (Figure Id ) . In general we can pa r t i t i on constraint graphs in to sets of " m u tua l ly independent" variables, where there is no direct constraint between any pair of variables in the set. Such a set is called a stable set in graph theory. Consider the constraint graph shown in Figure 2, for the prob lem of label ing the cube. The scene labeling problem Waltz., 1975 provides an appl icat ion domain here, but those unfami l ia r w i t h it can regard the cube as an abstract constraint graph The graph in Figure 2b is s imply a redrawing of the constraint graph in Figure 2a. Observe tha t the variables F and C are not jo ined by a const ra in t , nor are B and D, not A and E. There are no edges between variables at the same level in Figure 2b. Once a value has been chosen for (7, the values for F and C may be chosen mutua l l y independent ly, then values for D and D, and so on. (F igure 2b is a generalized fo rm of an "ordered constra in t graph" [Freuder, 1982. ) Many interest ing improvements on basic backt rack ing have been made Haral ick and E l l i o t t , 1980; Gaschnig, 1978]. General ly these improvements operate at a "microlevel," invo lv ing the relat ionships between ind iv idua l values for variables, e.g., value a for var iable x is inconsistent w i t h value b for var iable y. Our concerns are at a "macro leve l , " i nvo lv ing the relat ionships between the variables themselves, e.g., there is no constraint between variables x and y. A more detai led exper imenta l comparison w i t h one of the best of the backtrack var iat ions is made later E. Freuder and M. Quinn 1077 I I P S E U D O T R E E S E A R C H A L G O R I T H M Given a constraint graph par t i t ioned in to stable .sets, we wou ld like to take advantage of direct independence not only on one m a x i m a l stable set (or an app rox ima t ion thereof) , but on al l the stable sets. For example, we wou ld l ike to use the stable sets ident i f ied in Figure 2 as "levels" in a generalized backtrack a lgo r i t hm that employed the basic "add i t i ve " insight of Section 1 at each level. This can be done, up to a po in t , in a s t ra ight forward way Proceeding down th rough the levels, each var iable at a given level can be considered independent ly . However, a problem arises in backt rack ing. If two variables at one level have a constraint path down to a single var iable at a lower level (as in Figure 2b) , al l combinat ions of values for the two higher level variables may need to be tr ied before f ind ing one compat ib le w i t h the lower level var iable Thus, we again have a " m u l t i p l i c a t i v e " rather than an "add i t i ve " effect. Def in i t ion : A pseudo-tree is a rooted tree T (V. E) augmented w i th zero or more add i t iona l edges /,'' such that all edges between some vertex v and vertices closer to the root be along the path in T f rom v to the root The level of a var iable in a pseudo-tree is its level in the under ly ing rooted tree A pseudo-tree st ructured constraint graph supports an a lgo r i thm that avoids the "mu l t i p l i ca t i ve backtracking" , problem cited above. It also makes it easy to determine what variables need to be modified dur ing backt rack ing Th i rd l y , the pseudo-tree proper ty makes the constra int sat isfact ion problem more amenable to solut ion on a mult iprocessor, because a processor could t ry to assign values to a var iable and all its descendenis w i thout having to communicate w i t h other processors Freuder and Qu inn , 1985 Pseudo-Tree Search A lgo r i t hm The fo l lowing lemma proves that the pseudo-tree search a lgo r i thm has a complex i ty bound exponent ia l in the number of levels in the pseudo-tree, rather than in the number of variables in the problem In the next section we present an a lgo r i thm for t ransforming an arb i t ra ry constra int sat isfact ion problem in to an equivalent "me tap rob lem" w i t h a pseudo-tree constraint graph s t ructure. Lemma: Given a pseudo-tree T and A variables at level m in T, each var iable capable of tak ing on b values, the search a lgo r i thm backtracks at most bk t imes to level rn before backt rack ing to level rn 1. Proof: The first t ime the search a lgo r i thm reaches level m, the value of every var iable at that level is in i t ia l ized as low as possible. The search a lgo r i thm backtracks f rom level rn 1 in T when there exists at that level a var iable v that cannot be given a value that does not v io late constraints w i t h the values of ancestor var iables in T. By the pseudo-tree proper ty , al l of the variables const ra in ing v lie along a simple path f rom v to the root of T. In order to t ry al l combinat ions of values that might lead to an al lowable value of v, on ly vai iables along this path need to have their values changed Hence every t ime the search backtracks to level rn, exact ly one of the variables w at level m must have its value modi f ied. The value of w cannot be decremented: all lowei values were previously held by w and led to a backt rack ing lower in the tree. Because it is only necessary to reset the value of w when one of its ancestors has its value incremented, the value of no variable at level m w i l l lowei un t i l the search backtracks f rom level m. Since there are k variables, each w i t h b possible values, the m a x i m u m number of values variables at level m can take on before one var iable has no more possible values is bk, Theorem: Given a pseudo-tree T w i t h rn levels, each level / conta in ing A:, variables capable of tak ing on b, values, the worst-case t ime complex i ty of our a lgor i thm is Coro l la ry ; Given a pseudo-tree T our a lgo r i t hm can f ind one assignment of values to variables that satisfies the const ra in ts , if one exists, but it cannot be used to find all solut ions that satisfy the constra ints. I l l D E R I V I N G P S E U D O T R E E M E T A P R O B L EMS A constraint graph can be subdiv ided in to subproblems, where each subproblem involves sat isfying a subset of the or ig ina l variables The problem of sat isfying al l the subproblems s imul taneously may then be regarded as a metproblem, w i t h the subproblems as metavariables It has long been recognized that pa r t i t i on ing a constraint, satisfact ion problem in to subproblems may s impl i fy the p rob lem. However, l i t t l e guidance is avai lable as to how and when to subdiv ide problems. One cr i ter ion for considering a problem subdiv is ion is the felici ty of the st ructure of the resul t ing metaprob lem. For example, if the metaprob lem has a tree s t ructured constraint graph on the metavar i ables, then it c an be solved in t ime l inear in the number of metavar i ables ; Mack wor th and Freuder, to appear Here we present a method lor produc ing a metaprob lem where the metavar iables are organized in to stable sets f o rm ing levels in a pseudo-tree constraint s t ructure. Recall that the previous section presented an a lgo r i t hm for pseudotree-struct ured problems, w 