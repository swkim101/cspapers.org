We show how a higher order logic, the calculus of constructions, can be used to give a simple, first principles treatment of record calculi, polymorphism, and subtyping. The development follows the constructive idiom of extracting implementations of equationally specified programs from proofs of their termination, with a logic for reasoning about programs, and a semantics that comes as a gratuity. In this framework, records are finitely specified functions where equality is decidable over the domain, with types that are a particular kind of logical assertion. By proving that a record specification satisfies its type, we can extract its implementation. While program extraction serves as a sort of compiler, proof normalization serves as an interpreter; the latter serves to ensure in some sense the coherence of the translation embedded in the former.
This simple minded approach lets us show, for example, that many inference rules found in record and object calculi can be derivedâ€”they are just provable lemmas in higher order logic. We see explicitly how from subtyping proofs we can extract, using conventional methods, coercion functions between underlying representations of data types. By further exploiting the computational metaphor of higher order logic, we can realize an interpreter for recursively defined objects, as well as subtype and inheritance relations between them. Recursive types for objects are explained by primitive recursion in higher types. The approach also gives a computational understanding of F-bounded polymorphism.