Most minicomputers do not distinguish in their architecture between addresses and other operands, with the result that operand size becomes a de facto limit on address size (and thus memory size). This has created serious problems for many architectures when attempting to build systems with large address space.
 It is possible, however, to make address size “invisible” to the programmer and independent of operand/word size. This is achieved by defining the architecture to segregate addresses from other operands, and to compensate for the number of storage words required to hold an address.
 In a system so designed, the assembly source code written by a programmer then becomes “independent” of the address size of the particular computer for which it is intended; differences in address size becoming the concern of only the assembler.
 The implementation of this concept in a new minicomputer architecture is described. The necessary features in the architecture are identified, and the manner in which the assembler treats addresses is described.
 The effects upon ease of programming of these features is considered, and the object code produced (from a single source code) for two systems with different address sizes is analyzed. It is found that the sample programs will be only 5% larger and 3% slower for a system with two-word addresses than for a system with one-word addresses.