Self-triggered implementations of controllers have been proposed as an alternative to traditional time-triggered implementations. In a self-triggered implementation, the control task computes the actuator signal as well as a triggering time that specifies the next time instant at which the control task should be run. Self-triggered implementations have the potential to decrease communication costs and CPU requirements over time-triggered ones, e.g., by running the steady-state plant in open loop for long intervals if there is no disturbance. We show that commonly claimed gains for self-triggered implementations are too optimistic. The analysis of most self-triggering algorithms ignore the execution times for computing the trigger times. We show, using implementations of several self-triggering algorithms proposed in the literature on common embedded platforms, that the execution time to compute the trigger time can be non-negligible compared to the trigger times, and may even be higher than the trigger time itself, rendering a naive implementation infeasible.
 We propose a hybrid implementation scheme for self-triggered control using state quantization and memoization of trigger times in a cache. We perform trigger-time computation tasks with low priority, and fall back on a time-triggered implementation when the trigger time computations are not guaranteed to finish in time (but use the computed results to update the cache). Our implementation achieves communication costs similar to self-triggered implementations and computation costs close to time-triggered implementations, while providing a bound for the region of practical stability.