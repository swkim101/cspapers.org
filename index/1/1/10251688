ion, and substitution is simple: fun replace_term (u,new) t = if t=u then new else case t of Fun(a,ts) => Fun(a, map (replace_term(u,new)) ts) | _ => t; fun abstract t = let fun abs i (Pred(a,ts)) = Pred(a, map (replace_term (t, Bound i)) ts) | abs i (Conn(b,As)) = Conn(b, map (abs i) As) | abs i (Quant(q,b,A)) = Quant(q, b, abs (i+1) A) in abs 0 end; fun subst_bound t = let fun subst i (Pred(a,ts)) = Pred(a, map (replace_term (Bound i, t)) ts) | subst i (Conn(b,As)) = Conn(b, map (subst i) As) | subst i (Quant(q,b,A)) = Quant(q, b, subst (i+1) A) in subst 0 end; Observe the use of the functional map to apply a function over a list, getting a list of results. This is used to handle the arguments of functions and predicates and the subformulae of connectives. 2.4 Parsing and printing A good quarter of Folderol is concerned with parsing and printing of formulae. Let us pass over this quickly. Abstraction is used only in the parser: given an input string for ∀x.A it parses A treating x as a constant, then abstracts over x. This is hidden in the function fun makeQuant q b A = Quant(q, b, abstract (Fun(b,[])) A); Recall that a constant is a 0-place function. Similarly the printer, given the formula ∀x.A, substitutes a constant named x for the bound variable in A. The output is misleading if the body already contains a constant x. A better printer would make sure the name was unique. Identifiers are sequences of letters or digits. Examples of terms include r 12 banana constants ?s ?12 ?apple variables f(x,?y) succ(succ(0)) function applications The parser is crude. It accepts f(f(f),f(f,f),f), for there is no table of function names. Also parameters cannot be expressed: an identifier by itself is