As the state of graphical user interface design theory continues to mature from its beginnings in the mid-eighties, emphasis on reducing the burden of interface programming has become more prevalent. Across the many popular computer platforms used professionally today, a myriad of interface building packages have been designed with this concern in mind. Currently, however, no standard design methodology exists and more importantly, no construction package has emerged that significantly reduces programming effort while still providing the application interface programmer with full control over the design process. Most interface construction tools are implemented so that the software developer retains full control over the elements of the design process that dictate interface object placement and interface control, but has no ability to completely specify how these components will look and how they function in unison. Interface look and functionality in most cases is rigidly controlled by the design software based on “standards” that exist on the hardware platform in use, While these pseudo standards, demonstrated by such systems as Microsoft Windows and Apple Macintosh, may have many commonalities, defining a design methodology that is applicable to all systems, providing the designer with the ability to make full use of the system capabilities, while still allowing some artistic creativity, has been difficult to achieve. The importance of combining the issues of interface consistency and streamlining the interface for the needs of each individual application’s needs has often been overlooked with emphasis always placed on consistency alone. The argument, as justified by certain research projects [1], is based on the idea that if every application a user encounters has the same, or at least similar, interface design then the process of learning to use that application becomes much easier. However, this perspective is based on the concept of a generalized target audience in situations where the application design engineer will have trouble gaining a meaningful understanding of the end user’s specific task requirements