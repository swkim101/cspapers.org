The notion of formal validation of software has been taken by some to mean the mathematical proof of correctness of the software. Seldom is it argued that testing of software (except exhaustive testing) formally validates the correctness of the software. In fact it has become a truism in certain parts of the software engineering field that testing can “show the presence of bugs not their absence!” We argue that testing can do more. In certain circumstances a well chosen test set provides as much assurance that a program is correct with respect to a specification as does a formal proof of correctness. We look upon the act of testing as a process in which test data (input-output pairs) are chosen to distinguish correct programs from incorrect programs. As such it is complementary to the learning process in which input-output pairs are given and the task is to select the program which produced the pairs. In well studied cases in which the learning process succeeds, the testing process also succeeds. Success for both processes is relatived to classes of functions. For the learning process this means that there is a class F of functions such that after seeing sufficiently many pairs, the learning process chooses the unique function that produced the pairs. The testing process in this interpretation is the discovery of a function T that maps functions in F to finite initial segments such that each initial segment uniquely identifies that function (i.e., the initial segment differs from all but one function in F). We have identified several classes of admittedly simple functions that satisfy this definition and whose testing function T is easy to compute. These classes include pattern functions and finite state transducers and classes represented by sets closed under well-quasi orderings. We’ve also identified, recursion theoretically, classes of functions satisfying the above. The difficulties with applying the above are similar to difficulties encountered by other methods that just consider programs as computing functions. Since the functional view of programs is quite narrow (what function does a payroll program compute?), the validation techniques application is narrow. To use as a validation method one has to first identify F, then find T, and finally show that all the correct and incorrect nronrams compute functions that lie in the class F. If a program then satisfies its test set (i.e., the pairs of the test set agree with the input output pairs of the program on the finite initial segment), then the program is formally validated. Normally the above method requires that the set of correct and incorrect programs be testable for equivalence. For general purpose programs, such testing is impossible. For restricted languages, however, testing for equivalence may be easy. In particular, finite state transducers can be tested for equivalence and such transducers are frequently used in specifying systems. Test sets developed for such transducers could aid in the automated generation of test cases at the design level.