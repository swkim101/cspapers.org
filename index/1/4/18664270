Note by preparer: The following material provides a paraphrased digest of the panel discussion and questions, not a verbatim transcript. Although approaches may differ widely, every object-oriented development method must solve essentially the same set of problems. Any application involves a set of basic ideas or underlying constructs that define a subset of the application domain. These constructs imply a variety of options for realization in data structures. In addition, applications involve behavioral elements: things the system must respond to and things it must perform. Together, these may be thought of as comprising a collection of partial and fragmented models. One way to look at a complete object-oriented analysis and design method is that it must associate the elements of these partially correlated models and merge them into a single unified model in which all behavior has been allocated to specific object classes as embodiments of underlying constructs. An important question is just what are the consequences of approaching this issue from different points of view. The dominant methodologies and orientations in object-oriented today, what might be termed the " traditional " approaches, begin with the constructs in the application domain, the domain entities or classes, as the initial focus and primary point of reference. A more heretical view is found in the approaches developed by the panelists, who make certain of the dynamic behavioral aspects of the application, the events and event sequences, the primary material from which an object-oriented architecture is delivered. If you look carefully at many different object-oriented methods you find evidence of " event-think " in addition to " object-think. " Some ten years ago, " essential systems analysis " articulated the crucial notion of " event-object partitioning, " recognizing that two themes are required for effective partitioning of large problems: event partitioning for functional behavior, object partitioning for information. Events alone are inadequate and objects/classes alone can't do it. We need two partitioning themes or orientations, regardless of the form of implementation " downstream. " Some problems are more effectively solved with both