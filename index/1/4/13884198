This paper presents a compilation framework that enables efficient sharing of executable code across distinct Java Virtual Machine (JVM) instances. High-performance JVMs rely on run-time compilation, since static compilation cannot handle many dynamic features of Java. These JVMs suffer from large memory footprints and high startup costs, which are serious problems for embedded devices (such as hand held personal digital assistants and cellular phones) and scalable servers. A recently proposed approach called quasi-static compilation overcomes these difficulties by reusing precompiled binary images after performing validation checks and stitching on them (i.e., adapting them to a new execution context), falling back to interpretation or dynamic compilation whenever necessary. However, the requirement in our previous design to duplicate and modify the executable binary image for stitching is a major drawback when targeting embedded systems and scalable servers. In this paper, we describe a new approach that allows stitching to be done on an indirection table, leaving the executable code unmodified and therefore writable to read-only memory. On embedded devices, this saves precious space in writable memory. On scalable servers, this allows a single image of the executable to be shared among multiple JVMs, thus improving scalability. Furthermore, we describe a novel technique for dynamically linking classes that uses traps to detect when a class should be linked and initialized. Like back-patching, the technique allows all accesses after the first to proceed at full speed, but unlike back-patching, it avoids the modification of running code. We have implemented this approach in the Quicksilver quasi-static compiler for the Jalape~ no JVM. On the SPECjvm98 benchmark suite, our approach obtains code space savings, in writable memory, of between 82% to 89% of that from our previous quasi-static compiler, while delivering performance that is typically within 1% to 7% of that approach, and which is competitive with the performance of the Jalape√±o adaptive optimization system.