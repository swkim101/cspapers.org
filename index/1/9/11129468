We investigate the problem of computing in a reliable fashion in the presence of faults that may arbitrarily corrupt memory locations. In this framework, we focus on the design of resilient data structures, i.e., data structures that, despite the corruption of some memory values during their lifetime, are nevertheless able to operate correctly (at least) on the set of uncorrupted values. In particular, we present resilient search trees which achieve optimal time and space bounds while tolerating up to <i>O</i>(√log <i>n</i>) memory faults, where <i>n</i> is the current number of items in the search tree. In more detail, our resilient search trees are able to insert, delete and search for a key in <i>O</i>(log <i>n</i> + <i>Δ</i><sup>2</sup>) amortized time, where Δ is an upper bound on the total number of faults. The space required is <i>O</i>(<i>n</i> + <i>Δ</i>).