The design of a hardware unit that performs unification operation is described and analyzed in this paper. In particular, the hardware unification unit is designed to replace the software "unify" function of an existing (UNSW) Prolog interpreter: at the same time. hardware circuits are used extensively to enhance its performance. Based on the design of the hardware unification unit and the statistics obtained from the software 'unify' function, it is shown that the speed of the hardware unification unit is faster than that of the 'unify" function by an order of magnitude. Because the unification is a fundamental operation of Prolog processing and because the 'unify' function is the most time consuming function during query processing, this hardware unification unit can be used to build high performance Prolog machines. 1. I n t r o d u c t i o n High performance Prolog machines are desirable in various applications. For example, the interactive environment of Prolog programming requires fast turn around time; real time applications of Prolog (e.g., robotics) need high performance Prolog processors; also. some complex expert system applications such as automatic layout generation need great computing power. It is well known that unification and backtracking are fundamental operations in Prolog processing. The time spent for these two operations during query processing is measured and analyzed in [1] . The measurement was done for a Protog interpreter UNSW Prolog interpreter [2] running under Unix l on a Vax 11/7802 computer. A result of the analysis for two Prolog programs, a quick-sort program and an eight-puzzle program, are shown in Figure 1: The unify(quick-sort) and unify(eight-puzzle) represent the time spent for the 'unify' function, which performs the unification operation, in each program evaluation; similarly, the lush(quick-sort) and the lush(eightpuzzle) represent the time spent for the 'lush' function that performs the backtracking operation and maintains the environment. The 'unify' function spends 55-70 % of total query processing time. The average execution time of the 'unify' function per call is 0.103 msec in the quick-sort program and 0.111 msec in the eight-puzzle program; the number of calls to this function is large. Two approaches can be taken to reduce the total time spent for the 'unify' function. The first approach is to reduce the number of calls to the 'unify' function: one can reduce the number of unifications by ordering literals and clauses or by using the cut operator [3]; the selective backtracking [4] is another way of reducing the number of unifications. T h e second approach is to reduce the execution time of the 'unify' function per call. We follow this approach, by proposing the hardware unification unit: a hardware unit that performs the unification operation very quickly. In particular, we are interested in a hardware unification unit that will replace the 'unify' function of the UNSW Prolog interpreter . Our approach is feasible because the amount of interaction between the 'unify' function and the remaining functions of the Prolog interpreter is very small. One advantage of designing a hardware unit that replaces the software 'unify' function is that we can use the remaining part of the existing software (e.g., the Prolog interpreter and its programming environment) without major modification. Another advantage is that any computer system can be tailored for efficient Prolog processing by adopting the hardware unification unit. Next section describes the 'unify' function of the Prolog interpreter. Section 2 explains the design of the hardware unification unit. In section 3, we describe the special features to achieve the fast processing. We show the performance of the hardware unification unit in section 4. Section 5 provides concluding remarks. K1 The UNIFY function of the (UNSW) Proiog processor In order for readers to understand the ~unify' function for which the hardware unification unit is designed, we present a brief description of that function in this section. Inputs to the 'unify' function are two terms. Each term is represented by two arguments: a pointer to the 1. Unix is the trademark of the AT&T Bell Laboratories. 2. Vax is the trademark of the Digital Equipment Corp. 0149-7111/85/0000/0198501.00 Â© 1985 I EEE 198 t erm record in the symbol table and a pointer to the variable stack. A term record contains the type of the term and other relevant information depending on i ts type. Each term can be one of the following seven types: ATOM, PREDEF. INT. LIST. FN. CLAUSE. VAR. The output of the "unify" function is TRUE or FALSE representing that the two input terms are unifiable or nonunifiable, respectively. Side-effects occur in the "unify' function when one of the input terms is an uninstantiated variable: the side-effect is to bind the input variable to the other input term and store this binding information in the variable stack. The 'unify ' function consists of eight service routines, each of which is executed in one of the following cases : * when types of both inputs are ATOM or PREDEF, when types of both inputs are INT, * when types of both inputs are LIST, * when types of both inputs are FN, * when types of both inputs are CLAUSE. * when the type of the first term is VAR, * when the type of the second term is VAR, and * when types of the two terms do not match. A block diagram of the 'unify ' function is shown in Figure 2: the eight service routines as well as the (abstract) control flow are shown in this figure. The 'unify ' function is invoked recursively i n s o m e of these service routines. The 'unify ' function uses various data structures during its operation: types of these data structures are shown in the first column of Table 1. The statistics of the 'unify ' function such as the number of memory accesses, the number of i terations for each loop and the branching probability are collected from the two programs mentioned in the previous section. For example, Table 1 shows the average number of memory accesses to each distinct port ion of memory per "unify' function call. The first two rows of Tables l(a) and lib) provides the number of memory accesses to the symbol table to get the type information and the value information, respectively. The average number of total memory accesses per 'unify ' function call is 9.85 in the quick-sort program and 9.59 in the eight-puzzle program. The detailed statistics, although not given in this paper for the sake of brevity, is used to calculate the expected execution time of the designed hardware unification unit (see s e c t i o n 4). 2. Design of the Hardware Unif icat ion Unit