Most portable compilers ignore the target architecture for optimization phases, deferring the introduction of machine specific information to a final code generation pass. Optimization phases in these compilers must make arbitrary assumptions about which techniques will produce faster code. In contrast, most vendor compilers utilize aspects of the machine architecture at all phases of the back end and as a result have sustained a track record of generating better code. Because of the extensive use of machine knowledge throughout all back end phases of a vendor compiler, these compilers have proved difficult to port. As architecture lifetimes have shortened and the number of architecture variants have increased, developing such optimizing compi Iers has become prohibitive y expensive. In this paper, we show how these costs can be amortized across a number of architectures with a framework for abstracting the machine information from a vendor compiler. We also discuss the tools we are building to tailor the abstract compiler to an architecture specified by a comprehensive machine description. In the TOAST (Tailored Optimization And Semantic Translation) abstract compiler, all references to target architecture specific information are made indirectly through information derived from a machine description. A TOAST machine description contains the physical resources available, a timing model, and the semantics of each instruction expressed as a small set of primitives. The abstract compiler has no knowledge of the kinds of the instructions available on the architecture or the relative performance of these instructions. In some cases, the information needed by the abstract compiler is easily derivable from the machine description. In other cases, analysis of the semantics of the instructions is required. The tools to perform this analysis are the novel aspect of the TOAST system and are the primary focus of this paper. We use the following terminology throughout: