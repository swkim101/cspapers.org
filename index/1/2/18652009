An efficient mechanism for method lookup is csscntial in any reasonable implementation of a clussbased object-oriented language. One tcchniquc, static caches, provide constant time lookup, but consumes cxcessive memory. To alleviate the memory consumption problem many systems USC a coloring schcmc that allows cache rows to be shared and thus reduces the ovcrall cache size. This technique is easily implcmcntcd I’OI stongly typed languages such as C++ and Eiffcl, but not for languages such as CLOS or Smalltalk. This papct provides a solution to this latter problem: that of coloring for static caches in dynamically typed objcct-oricnted languages. Our solution is to use an incrcmcntal coloring algorithm to avoid the memory consumption problems of the naive approach. l-Introduction Object-oriented programming is an attractive programming sub-paradigm for many reasons, not the lcast of which are: polymorphism, encapsulation, mcssagc Permission to copy without fee all or part of this material is granted provided that the copies are not made or distributed for direct commercial advantage, the ACM copyright notice and the title of the publication and its date appear, and notice is given that copying is by permission of the Association for Computing Machinery. To copy otherwise, or to republish, requires a fee and/or specific permission. @ 1992 ACM 0-89791~539-9/92/OOlOlOl 10...$1.50 passing, inheritance, instantiation, and dynamic binding. Object-oriented programming provides interesting solutions to the problems of software quality through reusability, extensibility, and modularity [MEY 881. One of the key tenets of software engineering is execution efftciency. By Moon’s definition [MOO 861, execution efficiency consists of making good use of hardware resources, e.g., the processor, memory, communications, etc. Moon distinguishes four measures: the programmer’s time, CPU time, page fault rate, and virtual memory occupied. The last three features correspond to typical weaknesses in the implementation of object-oriented languages. Poor execution efficiency is the classic reason for users to deprecate systems such as Smalltalkand CLOS, and to embrace compiled, statically typed languages such as Eiffel and C++. One contribution to poor execution efficiency in languages such as Smalltalkand CLOS is the cost of method lookup. One way to reduce the cost of method lookup is to use a static lookup cache. Using such a cache provides the system with a constant time method lookup, independent of the inheritance hierarchy structurc and the method distribution. Unfortunately, these caches can consume large amounts of memory. One technique that is used to reduce this memory consumption is to use selector coloring to fold non-conflicting selectors into single cache entries [DIX 891. This technique has been implemented in a number of existing compiled languages, although the coloring time OOPSLA’92, pp. 1 lo126 and size of the conflict graph arc often prohibitive. Many situations lead to a large computational overhead (the coloring time) without resulting in signilicant bcncfits (less memory consumption). In this paper, we invcstigatc method lookup caches in languages that allow dynamic class modilications. These are object-oriented languages with: dynamic typing (e.g., Smalltalkor CLOS), dynamic binding (the method lookup is done at cxccution time). WC call languages with thcsc fcaturcs S-languages. Such languages are very attractive to programmer’s for a number of reasons, one of the most important being the ability to obscrvc the cffccts of a few local moditications without waiting for a Icngthy rc-compilation. In this paper WC show that Dixon’s algorithm [DIX 891 is not a good fit to &languages, and then WC propose a simple incremental version that colors the sclcctors in a reasonable time and number of colors, and without a large memory overhead. Section 2 of this paper covers the background: the major method lookup improvement tcchniqucs, and their cache utilization. It also discusses the basic Dixon coloring algorithm. Section 3 discusses the advantages of coloring when implcmcnting &languagcs. Section 4 summarizes our cxperimcnts with the Smalltalk-801 system that verify the thcorics from section 3. Finally, section 5 dcscribcs our incrcmcntal coloring and summarizcs its improved results on the same Smalltalksystem.