We present a new approach to the exhaustive generation of rooted and free trees of n nodes. Our algorithms have the following features: (1) They are optimal in the sense of using linear space and having running times that are proportional to the number of trees produced. (2) They use a natural representation of the trees, the parent array. (3) They can generate the trees in many different orders, including reverse lexicographic order. (4) They are recursive, not iterahive. (.5) They can be easily modified to generate restricted classes of trees and still preserve properties (l)-(4). The possible restrictions are: (a) in the case of rooted trees, upper bounds on the number of children of a node and lower and up per bounds on the height of the tree; and (b) in the case of free trees, upper bounds on the degree of a node and lower and upper bounds on the diameter of the tree. 1 Background and Summary of Results Rooted trees occur throughout computer science, where, for example, they are used in data structures for disjoint sets, and in mathematics, where they are studied in conjunction with bracketing systems, and even in biology, where they are used for the evolutionary classification of species. Free trees (connected acyclic graphs) are a staple of graph theory and graph algorithms. Several algorithms have been developed for generating (i.e., listing) all rooted trees, all free trees, and their variants. The earliest algorithm seems to be that of Scions [lo]. He represented a rooted tree by “level sequences”, obtained by recording the levels (distance to the root) of each node in a pre‘Research supported in part by the Natural Sciences and Engineering Research Council of Canada under Grant -43379. e-mail: fruskey@csr . uvic. ca order (depth-first-search) traversal. In order to identify a unique “canonic” tree, the rooted trees are (recursively) drawn with subtrees of greater height to the left. The level sequences of canonic trees were then generated in lexicographic order. The most well-known algorithm for generating rooted trees is due to Beyer and Hedetniemi [l] (also described in the book of Wilf [14]). The algorithm also uses level sequences, but generates them iteratively in relex (reverse lexicographic) order. Moreover, they were the first to prove that an algorithm for generating rooted trees did so in constant time: amortized over all trees. We call this the CAT property (for Constant Amortized Time). Another method of generating rooted trees was developed by Kozina [4] but it seems to have no advantages over the other two mentioned above, and has a running time of O(nr,), where P, is the number of rooted trees on n nodes. Generating free trees is considerably more complicated. A center in a tree is a node that minimizes the maximum distance to any other node in the tree. It is well-known that every tree has either one center (is unicentral) or has two centers (is &central), and that the two centers of a bicentral tree must be adjacent. The main idea most algorithms for generating free trees is to root the free tree at one of its centers and then generate the resulting restricted class of rooted trees. Scions [lo] discussed the problem: and Read [9] developed and algorithm which iS impractical since it had to store all trees of n 1 nodes to generate those with n nodes. Kozina [4] developed an algorithm that uses linear space and which generated bicentral and unicentral trees separately, with running time O(n’r,). -4nother algorithm with the same running time as Kozina’s was developed by Liu [‘il. Tinhofer