We introduce the new framework of Labeled Terms Rewriting Systems (T~RS), a general framework to express sharing in Term Rewriting Systems (TRS). For Orthogonal TZRS, an important subclass of T~ RS, we characterize optimal derivations. This result is applied to weak A-calculi, showing the optimality of the tazy strategy, that is, the call-by-name with sharing strategy. The result is also valid in the presence of &rules, as in PCF. Orthogonal T~RS is also useful as a calculus for proving syntactic properties of functional languages. 1 Compilation of the ~-calculus Most compilers for functional languages translate their source language into some enriched Acalculus [17], and then, compile this intermediate language to a low-level language, such as mutually recursive supercombinators, as in LML [2, 10], or categorical combinators, as in CAML [4]. These low-level languages define different forms of weak /3-reduction. We now describe two of these low-level languages, supercombinators and explicit substitutions, and gradually introduce our extensions to the TRS formalism, â€œ INRIA Rocquencourt ; this work was partially funded by DRET under grant N08780814. Permission to copy without fee all or part of this material is granted provided that the copies are not made or distributed for direct commercial advantage, the ACM copyright notice and the title of the publication and its date appear, and notice is given that copying is by permission of tbe Association for Computing Machinery. To copy otherwise, or to republish, requires a fee and/or specific permission. @ 1990 ACM 089791-419-8/90/0012/0255 $1.50 1.1 Compilation to supercombinators Consider the following A-expression : The compilation into supercombinators yields a set of combinator definitions and an expression to be computed : L/ II X=X 12X=X Kxy=.z Ffz=f(Gfz) Gfz=fx F (K 11) IZ Note how the variable f, free in (Jz.f z), is turned into a locally bound variable which is supplied while calling the supercombinat ors F and G. This process is known as A lifting [2]. These expressions are graphs, to be reduced by the method of lazy graph reduction [2, 17]. There is an implicit binary application node, written @ in the following. As an example, the expression F (K 11) 12 is equivalent to @(@(F, @(I<, 11)), 12), or graphically :