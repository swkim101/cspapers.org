Lazy (normal order) languages [5, 8, 201 defer evaluation of expressions until they are required, As a result, they admit a more powerful semantics allowing infinite list structures, like streams [15], and the construction of programs as mathematical expressions which have the same meaning regardless of evaluation order. Unfortunately, there is a significant operational expeboth space and time associated with each delayed evaluation. Local bindings must be retained until every lazy reference to them has been resolved, requiring space to hold many environments. Extra context switching becomes a major expense over time. Also, every use of a potentially postponed evaluation requires a test to determine whether the evaluation has been performed [2]. In contrast, conventional languages use an applicative order (call-byvalue) protocol which avoids these costs. Thus, most users have come to expect performance better than faithfully lazy implementations can provide. A compiler that detects unnecessary laziness would produce code that avoids much of thii overhead, injecting call-by-value behavior into expressions and regaining the efficiency of conventional implementations wherever possible.