A programming language may be viewed as an acceptable numbering of the partial recursive functions, with “semantics” the mapping from programs onto the functions computed [1]. (In this view, syntax receives little attention, although it is best to consider it as a characteristic function of a recursive set of indices instead of allowing all natural numbers. Such a view is natural for the usual arithmetizations, and eliminates some possible confusions, for example in interpreting the recursion theorem for pairs of numberings.) The virtue of functional semantics is that the semantic range is a machine-independent class. The abstract view in which details of the semantic mapping are ignored, in which the function assigned to a program is “the one it computes,” with the enumeration and s-m-n theorems assumed to compensate for the lost detail, has found only a restricted application to programning-language problems. Computational complexity, in the successful abstraction by Blum [2], is an attempt to provide more semantic structure without introducing a tenacious machine-dependence. The Blum measures are not themselves suitable as a semantic range. Two programs may have the same measure function, yet compute wildly different functions in widly different ways; other programs, intuitively very similar, may have wildly different measure functions [3]. A composite semantics of a function computed and a measure function is much like the approach suggested here: using formal computation functions as the semantic range.