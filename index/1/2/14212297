Conventional operating system code is written to deal with all possible system states, and performs considerable interpretati on to determine the current system state before taking action. A consequence of this approach is that kernel calls which perform little ac tual work take a long time to execute. To address this problem, we use specialized operating system code that reduces interpretation for common cases, but still behaves correctly in the fully general c ase. We describe how specialized operating system code can be generated and bound incrementallyas the information on which it depends becomes available. We extend our specialization techniques to include the notion of optimistic incremental specialization : a technique for generating specialized kernel code optimistically for sys tem states that are likely to occur, but not certain. The ideas outlined in this paper allow the conventional kernel design tenet of “optimi zing for the common case” to be extended to the domain of adaptive operating systems. We also show that aggressive use of specialization can produce in-kernel implementations of operating system functionality with performance comparable to user-level implementations. We demonstrate that these ideas are applicable in real-world operating systems by describing a re-implementation of the HP-UX file system. Our specializedread system call reduces the cost of a single byte read by a factor of 3, and an 8 KB read by 26%, while preserving the semantics of the HP-UXread call. By relaxing the semantics of HP-UXread we were able to cut the cost of a single byte read system call by more than an order of magnitude.