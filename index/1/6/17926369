To maximally conserve the critical resource of battery energy, smartphone OSes implement an aggressive system suspend policy that suspends the whole system after a brief period of user inactivity. This burdens developers with the responsibility of keeping the system on, or waking it up, to execute time-sensitive code. Developer mistakes in using the explicit power management unavoidably give rise to energy bugs, which cause significant, unexpected battery drain.
 In this paper, we study a new class of energy bugs, called sleep conflicts, which can happen in smartphone device drivers. Sleep conflict happens when a component in a high power state is unable to transition back to the base power state because the system is suspended when the device driver code responsible for driving the transition is supposed to execute. We illustrate the root cause of sleep conflicts, develop a classification of the four types of sleep conflicts, and finally present a runtime system that performs sleep conflict avoidance, along with a simple yet effective pre-deployment testing scheme. We have implemented and evaluated our system on two Android smartphones. Our testing scheme detects several sleep conflicts in WiFi and vibrator drivers, and our runtime avoidance scheme effectively prevents sleep conflicts from draining the battery.