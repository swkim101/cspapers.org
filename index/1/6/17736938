The Maximum Weight Independent Set of Polygons (MWISP) problem is a fundamental problem in computational geometry. Given a set of weighted polygons in the two-dimensional plane, the goal is to find a set of pairwise non-overlapping polygons with maximum total weight. Due to its wide range of applications and connections to other problems, the MWISP problem and its special cases have been extensively studied both in the approximation algorithms and the computational geometry community. Despite a lot of research, its general case is not well-understood yet. Currently the best known polynomial time algorithm achieves an approximation ratio of ne, and it is not even clear whether the problem is APX-hard. We present a (1 + e)-approximation algorithm, assuming that each polygon in the input has at most a polylogarithmic number of vertices. Our algorithm has quasi-polynomial running time, i.e., it runs in time 2poly(log n, 1/e). In particular, our result implies that for this setting the problem is not APX-hard, unless NP âŠ† DTIME(2poly(log n)). 
 
We use a recently introduced framework for approximating maximum weight independent set in geometric intersection graphs. The framework has been used to construct a QPTAS in the much simpler case of axis-parallel rectangles. We extend it in two ways, to adapt it to our much more general setting. First, we show that its technical core can be reduced to the case when all input polygons are triangles. Secondly, we replace its key technical ingredient which is a method to partition the plane using only few edges such that the objects stemming from the optimal solution are evenly distributed among the resulting faces and each object is intersected only a few times. Our new procedure for this task is no more complicated than the original one and, importantly, it can handle the difficulties arising from the arbitrary angles of the input polygons. Note that already this obstacle makes the known analysis for the above framework fail. Also, in general it is not well understood how to handle this difficulty by efficient approximation algorithms.