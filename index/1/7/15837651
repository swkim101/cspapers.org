Transactional programs, using transactional memory (TM) and non-transactional programs (non-TM) (e.g., using locks) provide weak semantics under commonly used memory models. Strong memory models incur high implementation overhead and yet prove to be insufficient. TM programs and non-TM programs have different semantics based on the memory model. Adding new atomic blocks to lock-based code is difficult without adding high overhead or introducing weak semantics. A system where users can add atomic blocks or lock-based critical sections seamlessly to existing TM programs or lock-based code facilitates incremental deployment. A unified and strong memory model enforced efficiently by a single runtime for both kinds of programs is therefore desirable.