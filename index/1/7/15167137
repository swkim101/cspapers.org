In most general purpose computer systems there is a wide varietyof software available to users. Such software is usually providedin one of three organisational forms - routines in a library;collections of related functions grouped in a package with a commoninterface; independent programs called through operating systemcommands. This interdependent tripartite structure creates problemsfor non-sophisticated users as it involves different levels of userinterface complexity.At the routine level a user must writeprograms in an appropriate host programming language to use thesoftware. If he wishes to use a selection of routines written inincompatible languages then he may have to familiarise himself withmore than one host language. In each language he must be aware ofthe calling conventions for routines, the possible representationsof various types of data, the methods of passing parameters and theways of inputting and outputting data to and from the externalenvironment. This type of interface occurs with libraries like NAGand IMSL.
In the case of packages the imperative user interface is usuallysomewhat simpler, consisting essentially of a name identifying thefunction required and some associated parameters which identifyvariables, labels, files, options, control and code values, etc asappropriate. However, function calls of this form must normally bepreceded by a non-trivial amount of declarative and other "redtape" information expressed in the package interface language.Also, package environments can be restrictive in that the user isconstrained to the types of data structure and analysis supportedby the chosen package unless he is prepared to write programs totransform his data for other packages or to analyse itindependently. SPSS is typical of this kind of package.
When software facilities are provided at the program level, theuser interface often consists simply of one-line program invocationcommands written in the local operating system's command language,with program options and data files identified by commandparameters. Common examples of such facilities are sort andarchiving programs. A program level interface becomes even simpler,and at the same time more powerful, if command sequences can beformed into parameterised command procedures and if programs areenabled to conmlunicate directly with one another without the needfor explicit intermediate files.
In the latter type of environment the application software usergenerally finds that there are analytic program tools available tomeet only some of his requirements. Consequently he has to embraceeither or both of the other levels in addition in order to increasethe analytic power available to him. Transfer between levels is noteasily accomplished in most systems as facilities do not normallyexist to help the user move data between levels. This difficultycomes on top of the obvious problem of having to master more thanone interface and more than one level of complexity.
In the SENSE project (11), which is funded by the U.K. SocialScience Research Council, we are creating a prototype computingenvironment for social science researchers which can accommodatenon-sophisticated users. The aim is to provide an integratedenvironment where such users will have a complete range ofapplication software available (packages, routines and programs)through a single, simple user interface. We believe that this canbe achieved by exploiting and extending the concept of softwaretools propounded by Kernighan and Plauger (19), so that as far aspossible all software can be used through a program levelinterface, with its attendant advantages. Following Kernighan andPlauger we believe that software tools "can be used to create acomfortable and effective interface to existing programs", as wellas providing an ideal model for the structuring of brand newapplication software. This paper will consider various aspects ofthe initial design of the SENSE software environment withparticular reference to the importance of software tools in thatdesign.