A hash table is a data structure for representing a set of n items that uses linear space and supports membership queries in O(1) time. We show how to construct a hash table for any given set in O(log log n) expected time using n processors on a weak version of a CRCW PRAM. We also show that optimal speed-up can be obtained, i.e., the expected running time is n/p, when the number of processors p is < n/ log log n log* n. A general paradigm for the design of randomized algorithms is introduced. This method is used in our algorithm and may be useful in the design of other fast randomized algorithms. 1 Introduction. 1.1 Hash Functions and Static Hash Tables. Let S be a set of n keys drawn from a finite universe U. Let h be a function U L [0,.. .,s – 1] (such functions are called hash functions). We call h a perjeci hash function for S if there are no two keys in S that are mapped by h to the same value. We call h a good lookup function for S ifi (i) h is perfect for S; (ii) h uses linear storage (i.e., s = O(n)); (iii) h can be represented in O(n) space; and (iv) h supports quick lookups, i.e., for every x c U, h(z) can be evaluated in 0(1) time by a single processor. A good lookup function induces an O(n) storage data structure for representing S, with 0(1) time for lookup query. Such a data structure is called linear static hash table. In this paper the problem of constructing in parallel a good lookup function for a given input set is considered. We provide fast and efficient parallel algorithms for this problem. The algorithms make use of novel techniques that avoid counting and sorting and thereby circumvent the barrier caused by the Q(log n/ log log n) lower bound for these problems [4]. In particular we demonstrate that hashing is easier than sorting from the parallel perspective, in the sense that it can be done much faster (similarly to the sequential case). of algorithms whose fast running time precludes usage of basic tools like counting is especially challenging; this research presents two tools that may be useful in this context: a) A general paradigm for designing fast parallel randomized algorithms. b) A scheme for the use of …