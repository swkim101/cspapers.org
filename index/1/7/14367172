The PLM is a co-processor a r c h i t e c t u r e designed for efficient execu t ion of Prolog programs. It is the first p ro to type of a logic processor for our Aquarius he te rogeneous MIMD machine . Current ly , it is a t t a ched to an NCR/32 sys t em which provides the memory and I /O subsys tems as well a~ process ing power for o the r opera t ions no t su i ted to the func t i ona l u n i t of the PLM (e.g. f loating po in t operat ions) . This paper descr ibes the a r c h i t e c t u r e of the PLM and some aspects of its imp lemen ta t ion . We conclude with an analysis of some pe r fo rmance da ta ob ta ined f rom a s imula t ion of the design. I . I n t r o d u c t i o n This paper descr ibes a special purpose processor, the PLM, which we have designed for high pe r fo rmance execu t ion of Prolog programs. It is pa r t of Aquarius [4], a high ~ pe r fo rmance he te rogeneous MIMD mul t ip rocessor being designed at Berkeley. Figure 1 is a n overall block d i ag ram of Aquarius. The goal of the Aquarius Project is to u n d e r s t a n d the pr inciples , by which a mach ine can be organized f rom diverse func t iona l un i t s such t h a t i t will c o n c u r r e n t l y execute bo th symbolic and n ume r i c operat ions . The approach is to suppor t logicp rogramming at the con t ro l level and a r ray opera t ions at the func t iona l level. It is envis ioned t h a t the mach ine will employ a var ie ty of a u t o n o m o u s VLSI components ; each with considerable , if specialized, c o m p u t a t i o n capabil i ty. The cont ro l language is adapted to i ts source language and can bes t be t hough t of as an i n t e r m e d i a t e fo rm of PROLOG [3,8J, m u c h as P-code is t hough t of as an i n t e r m e d i a t e fo rm of PASCAL. It is compiled p r io r to execu t ion f rom PROLOG or o ther high-level, logicp rogramming languages. In this paper, we focus on the pe r fo rmance of a processor a rch i t ec tu re , specialized for the execu t ion of the cont ro l language. The Aquarius group has r ecen t ly designed a special co--processor , the P rogrammed Logic Machine (PLM), as the first expe r imen ta l processor of the new system. We have s imula ted it a t several levels of detai l dur ing i ts design, and have now c o n s t r u c t e d it in TTL logic, It is composed of abou t 500 chips, r ang ing f rom simple ga tes to LSI c i rcu i t s (e.g. PAL's). At the t ime of this writing, the TTL vers ion of the processor is being debugged, so a t t he moment , we can only repor t on our s imula ted resul ts . The purpose of this paper is to r epor t on the improvemen t in pe r fo rmance t h a t can be achieved by a special ized a rch i tec tu re . 2. The A r c h i t e c t u r e This sec t ion descr ibes the overall a r c h i t e c t u r e of the Aquarius-I sys tem as shown in Figure 2. The processor is a t t a ched to the PM Bus of the hos t NCR/32 s y s t e m Also a t t a ched to the bus are the hos t cen t r a l processor, I /O co-processor, and floating poin t co-processor , as well as the ma in memory u n i t and i ts associa ted address t r a n s l a t i o n uni t . F u r t h e r detai ls of the NCR/32 sys tem can be found in [I]. SectiOn 2.1 descr ibes the a b s t r a c t execu t ion model and I n s t r u c t i o n Set Archi tec ture (ISA) of the PLM. Sect ion 2.2 descr ibes the PLM in te r face to the PM bus, the PLM Memory In te r face u n i t (PMI). Sec t ion 2.3 descr ibes the Prolog engine. 2, I. A b s t r a c t M o d e l a n d ISA 2.1.1. A b s t r a c t M o d e l . As seen in Figure 3, a Prolog [3] p r og r a m is a col lect ion of procedures . Each p rocedure is a col lect ion of clauses. A clause has a head (or goal) and a body consis t ing of p rocedure calls (sub-goals). If the body is empty, the clause becomes a "fact". The head has a p red ica te (or functor ) and a col lect ion of a r gume n t s (which can be empty). Execut ion proceeds as follows: t Given a goal (query) (with the fo rmat of a head): (1) Find the first c lause in the p r o g r a m which has a ma tch ing p red ica te and whose a r g u m e n t s will "unify" [TJ with the goal. Unif ica t ion is a ma tch ing process which will genera l ly b ind some variables. (2) Invoke each sub-goal, of the body of the clause, as a goal. -If all sub-goals succeed, t h e n the clause succeeds and all var iable b ind ings are valid. -If a sub-goal fails, b a c k t r a c k to the mos t r e c e n t subgoal vis i ted dur ing the execu t ion a t which a f u r t h e r choice exists ( indica ted by a "choice-point") . -If all. the choices wi thin a c lause ' s sub-goals are exhaus ted ( r e t u r n failure), t h e n give up on the c u r r e n t c lause and t ry to un i fy the goal with the nex t c lause in the procedure . -If the re are no f u r t h e r ma tch ing clauses, r e t u r n failure. The design of the PLM is based on an a b s t r a c t model for Prolog execu t ion a nd i n s t r u c t i o n set a r c h i t e c t u r e (ISA) original ly descr ibed by Warren [12J and modified by Dobry, P a t t a nd Despain [6]. Under th is model, the address space of the PLM is divided in to two separa te and d i s t i nc t areas, the Code Space a nd the Data Space. The Code Space is a p seudo-s t a t i c t An excellent tutorial on Prolog is in the text by Clocksin and Mellish [2]. 0149-7111/85/0000/0180501.00 Â© 1985 I EEE 180