In practice, the design of distributed systems is often geared towards optimizing the time complexity of algorithms in %orrnal " executions, i.e. ones in which at most a small number of failures occur , while at the same time building in safety provisions to protect against many failures. In this paper we present an optimally fast and highly resilient shared-memory randomized consensus algorithm that runs in only O(log n) expected time if @or less failures occur, and takes at most O(*) expected tim~ for any j. Every previously known resilient algorithm required polynomial expected time even if no faults occurred. Using the novel consensus algorithm, we show a method for speeding-up resilient algorithms: for any decision problem on n processors, given a highly resilient algorithm as a black box, it modularly generates an algorithm with the same strong properties, that runs in only O(log n) expected time in executions where no failures occur. 1 Introduction 1.1 Motivation This paper addresses the issue of designing highly resilient algorithms that perform optimally when only a small number of failures occur. These algorithms can be viewed as bridging the gap between the theoretical goal of having an algorithm with good running time even when the system exhibits extremely pathological behavior, and the practical goal (cf. [19]) of having an algorithm that runs optimally on " normal executions,)' namely, ones in which no failures or only a small number of failures occur. There has recently been a growing interest in devising algorithms that can be proven to have such properties [7, 11, 13, 22, 16]. It was introduced in the context of asynchronous shared memory algorithms by Attiya, Lynch and Shavit [7]. 1 The consensus problem for asynchronous sha~ea' memory systems (defined below) provides a paradigmatic illustration of the problem: for reliable systems there is a trivial algorithm that runs in constant time, but there is provably no deterministic algorithm that is ' [11, 13,22, 16] treat it in the context of synchronous message passing systems.