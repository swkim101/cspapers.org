We introduce the lazy search tree data structure. The lazy search tree is a comparison-based data structure on the pointer machine that supports order-based operations such as rank, select, membership, predecessor, successor, minimum, and maximum while providing dynamic operations insert, delete, change-key, split, and merge. We analyze the performance of our data structure based on a partition of current elements into a set of gaps $\{\triangle_{i}\}$ based on rank. A query falls into a particular gap and splits the gap into two new gaps at a rank $r$ associated with the query operation. If we define $B=\Sigma_{i}\vert \Delta_{i}\vert \text{log}_{2}(n/\vert \Delta_{i}\vert)$, our performance over a sequence of $n$ insertions and $q$ distinct queries is $O(B+\text{min}(n\ \mathrm{log\ log}\ n, n\ \text{log}\ q))$. We show $B$ is a lower bound. Effectively, we reduce the insertion time of binary search trees from $\Theta(\text{log}\ n)$ to $O(\text{min}(\text{log}(n/\vert\Delta_{i}\vert)+ \mathrm{log\ log}\vert\Delta_{i}\vert,\ \ \text{log}\ q))$, where $\Delta_{i}$ is the gap in which the inserted element falls. Over a sequence of $n$ insertions and $q$ queries, a time bound of $O(n\ \text{log}\ q+q\ \text{log}\ n)$ holds; better bounds are possible when queries are non-uniformly distributed. As an extreme case of non-uniformity, if all queries are for the minimum element, the lazy search tree performs as a priority queue with $O(\mathrm{log\ log}\ n)$ time insert and decrease-key operations. The same data structure supports queries for any rank, interpolating between binary search trees and efficient priority queues. Lazy search trees can be implemented to operate mostly on arrays, requiring only $O(\text{min}(q, n))$ pointers, suggesting smaller memory footprint, better constant factors, and better cache performance compared to many existing efficient priority queues or binary search trees. Via direct reduction, our data structure also supports the efficient access theorems of the splay tree, providing a powerful data structure for non-uniform element access, both when the number of accesses is small and large.