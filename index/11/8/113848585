Models are used in control domains such as automotive and avionics for early validation of system properties, using simulation or formal verification (model-checking), and for the automatic generation of control software. Model-Based Design (MBD) tools such as Simulink [1] and Scicos [2], [3], based on a synchronous-reactive (SR) execution semantics, allow the modeling and simulation of hybrid systems, in which functionality is represented using an extended finite-state machine formalism. Early verification of the system functionality by simulation or model-checking is highly valuable in many modern robotics systems, which perform complex actions demanding a timely, predictable and certifiably safe behaviour in many applications (e.g., disaster recovery and space exploration). MBD modeling tools represent the control functionality in abstract terms, that is, executing according to a set of events in logical time. When the functionality is implemented on a computing platform that executes the controls as a set of software tasks and network messages, the synchronous assumption (conformance with respect to the model execution semantics) must be preserved despite computation and communication delays [4]. In most cases, designers are interested in a looser property, called flow preservation, consisting of the guarantee that the signal data in the implementation are the same as in the model. However, checking whether a platform allows for a flow-preserving implementation (or possibly synthesizing one), or evaluating the consequences of additional delays in case an implementation without delays is not feasible, requires a detailed model of the control implementations and the execution hardware and software [5]. We propose an approach in which a functional model of the controls is matched to a purposely constructed model of the execution platform through an intermediate mapping model, that represents the software tasks and messages (local or on the network) that realize the functions on the given platform. For the model of the execution platform, there are several possible options. Our objective is to be able to represent the common execution hardware in use in robotics systems and, on top of it, the Orocos-RTT framework [6], which encapsulates communication and RTOS services and acts as a middleware.