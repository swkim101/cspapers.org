types. We added a process local (heap based) stora,ge class in a few days, ma,king non-persistent instances of the existing abstract types possible. Raising the storage problem to being a semantically visible portion of the system has another clear advantage for clustering. The storage ma,nagers all support a series of clustering levels. The normal arrangement is to support chunks (contiguous stora.ge), segments (a clustering of chunks) and areas (a clustering of segments); however any given storage manager is free to support any number of levels of clustering. For the default persistent storage type, a segment is the unit of transfer to and from disk and an area maps to a disk 74 OOPSLA ‘87 Addendum to the Proceedings October 1987 partition or file. As an alternative, process local objects have only two levels of clustering: chunks and segments, where segments are built along operating system paging boundaries in a virtual memory system. Since all storage managers support the sa.me basic model of clustering, it becomes a much simpler problem to export a strong clustering pragma language to the type implementor. In Vb ase, objects may be clustered at any clustering level, along semantic relationships. Typically, all of the separate storage pieces required to implement an object are clustered within the same chunk. This chunk is then clustered within the same segment as the chunks implementing another related object. For example, in a CAD application, all of the sub pieces of an assembly might be clustered within the same segment, thus requiring only a single disk transfer when accessing the assembly. Our experience in tuning applications to take advantage of the clustering capabilities of the system has been very favorable. We have reduced the disk activity of one application by more than a factor of five with only a change to the clustering actions. Mapping Objects from Disk to Memory David Maier, Oregon Graduate Center The desired properties for objects stored on disk and objects in use by an application program are quite different. A key desirable feature for disk storage is flexibility. We want objects and types to be free to change, we wa.nt to capture multiple aspects of an object, and we may want to support free-format portions of an object state. Further, we often want to access objects on disk by associatively accessing their states. Within program memory, however, we are willing to trade flexibility for faster access. Usually, a particular program is only interested in a certain aspect of an object, and thus, only part of the object’s state. We want object access in program memory to be competitive with access to record a.nd array structures being able to proceed by addressing rather than by searching. We are investigating ways to efficiently map flexible, variable-size objects on disk to more structured fragments of object state in program memory, The OBJFADS Shared Object Hierarchy Lawrence Rowe, University of California, Berkeley I strongly believe tha.t stand alone object-oriented da.ta.bascs do not, solve very n1an.v real-life problems. You must solve probIems tha.t involve business da.ta.. Wllen I talk to people that are building real world applications, they are not interested in yet another database system. OBJFADS is an object-oriented programming environment for POSTGRES, a nextgeneration database system designed to support engineering/scientific and expert system applications. OBJFADS h as a shared object hierarchy (i.e., a portion of the object hierarchy is shared with other users), a direct manipulation interface, extensible interface October 1987 OOPSLA ‘87 Addendum to the Proceedings 75 abstractions (e.g., active forms with user-defined field types), and integrated application generators (e.g., query/update interface generators). POSTGRES is an extensible relational DBMS (e.g., users can define new attribute data types and access methods) that provides support for complex objects, procedures (i.e., data of type “procedure”), activeions (e.g., active forms with user-defined field types), and integrated application generators (e.g., query/update interface generators). POSTGRES is an extensible relational DBMS (e.g., users can define new attribute data types and access methods) that provides support for complex objects, procedures (i.e., data of type “procedure”), active databases (e.g., alerters, triggers, and rules), precomputed values (e.g., procedures and rules), and historical data (including versions and snapshots). The OBJFADS shared object hierarchy is stored in a POSTGRES database. The major problem with this approach to sharing is efficient implementation of object referencing and updating. Object referencing time can be reduced by maintaining an object cache in the a.pplication program, by precomputing the main memory object representation, a.nd by pre-fetching related objects. The object cache reduces the time to fetch an object that is referenced frequently. POSTGRES precomputed procedures will be used to reduce the overhead required the first time an object is fetched from the database. Complex objects are typically represented by tuples in severa.l relations. To fetch an object, these relations must be “joined” and the data attributes must be coerced into the appropriate application data types. A precomputed procedure can maintain a copy of the main memory object representation in the database. Precomputation will reduce the time required to fetch the object while, at the same time, maintaining the relational representation in the database. Lastly, prefetching will be used to reduce the probability that an object will have to be fetched from the database when it is first referenced. Applications typically reference complex objects composed of several related objects. Prefetching all objects that make up the complex object reduces the database fetches. Because the DBMS has user defined types, and because we are going from a. da,tabase type system to a type system in the program language, a general type mapping facility is needed. For existing database systems, the types are fixed. Therefore, existing database systems pretty much wire the mapping into the run-time system of a programming language. In contrast, in POSTGRES, objects can be shared and they can reference local objects. Therefore, when a shared object is saved in the database system, that object needs to be “unbound” from the run-time system, and a description of how to recrea.te it needs to be stored in the database. Similarly, when ‘the object is retrieved from the database into memory, that object needs to be recreated from its description stored in the database. We ran into lot of problems in this process when we dealt with objects such as windows and I/O ports. For example, when an object is retrieved from the database, it has windows defined in the X window server. It must be able to recrea.te those windows from a description stured in the database on how to generate them. Support for composite objects is absolutely needed. Won Kim’s paper on composite object in the OOPSLA ‘87 proceedings looks real interesting. There are two wa.ys to support composite objects. If you do records and pointers, you get into the prefetching and clustering “racket.” The second thing you can do is to use rehtions with precomputed procedures. Th e nea.t thing about precomputed procedures, for a.t least the queries they express, is that they do perfect caching. It makes query optimization a lot easier. The Utility of a Uniform Distributed Transaction Facility for 76 OOPSLA ‘87 Addendum to the Proceedings October 1987 Supporting Object-Oriented Databases Alfred Spector, Carnegie Mellon University Databases of all types, be they as simple as file systems or as complex as the latest extensible database management systems, can benefit from a carefully implemented distributed transaction facility. Such a facility should, at minimum, support inter-transaction synchronization; recovery after transaction abort, and node, server, and media failures; commit management; and location-transparent calls on objects. I argue that such facilities can have easy to use interfaces and be highly efficient. As an example, I will briefly sketch the interface to the Camelot Distributed Transaction Facility, which my group has built at Carnegie Mellon. Camelot is intended for production use in a number of application environments, including on-line transaction processing and special purpose databases. Camelot Release 0.7(31 )-aleph p resently runs on the Unix-compatible, Mach operating system on IBM RT PCs, DEC V axes, and Sun 3’s in the DARPA internet environment. Camelot provides coherent layers whereby we permit users to install subsystems. We permit people to issue remote procedure calls or methods on objects. We support all the commit protocols that you can conceive of. We handle recovery and provide security facilities. We have Mach, which is a Unix compatible distributed operating system that CMU is building and distributing. On top of Mach there are communication components, TCP/IP layer, and a message model with an RPC stub compiler. On top of that we have Ca.melot transaction facility, and then finally we can layer servers. Jeannette Wing at CMU is overseeing an effort to build a C++ derivative that has persistent objects that utilize recovery and transaction support in Camelot. Camelot is designed to support implementation of other object bases. We have plans underway to support a relational database system as well. At the kernel we have a process which restarts the system after crashes. We do our own disk management for objects. We do write-ahead logging based upon information from the data servers as to what they want logged, so we can take into account their semantic knowledge. Our programming libra,ries will do a pretty good job of deciding the minimum amount of logging to do for value logging. For operation logging, which we will support s