Static typing, also known as strong typing, has a long and rich history in programming languages. Object-oriented technology makes typing even more interesting for two reasons: l Basic object-oriented mechanisms (classes, inheritance, dynamic binding) yield a type system that is simple, flexible and powerful. . The typing problem in object-oriented programming, expressed in its basic form, is strikingly simple. In the fundamental object-oriented computation mechanism, the feature call (or message passing), written x.f in Simula/Eiffel syntax and meaning “apply feature f to the object attached to X, if any”, the typing question is simply: how and when can we check that this object will indeed have one or more operations corresponding to f? A statically typed language is one for which the answer to this question is: by mere examination of the software text, prior to any attempt at execution. (Directly related to static typing is dynamic binding, which answers the next question: assuming there are two or more operations corresponding to f, how do we guarantee that the one selected will be the right one?) Achieving static typing in an object-oriented context requires careful consideration of all the mechanisms needed and their interaction 1 Interactive Software Engineering Inc., 270 Storke Road, Suite 7 Goleta CA 93117 USA. Fax 805-685-6869, E-mail bertrand@eiffel.com Seriousness: there must be no way whatsoever to bypass the type mechanism. Casts and coercions (as in C-based languages, PL/I, Algol 68), type transfer functions (as in Modula-2), “unsafe” operations (as in Ada) are simply unacceptable in a language that claims to be typed. The type rules must suffer no exception. Consistency: the type system should be based on a small number of concepts, and encompass all types. In Eiffel, every possible type, including basic types such as INTEGER and REAL, is a class or derived from a class using inheritance and genericity. Inheritance: The basic way to create a new type from an existing one must be to base it on an heir class. Inheritance-based conformance: The basic constraint on assignment and argument passing must be based on inheritance: the source must be of a type based on a descendant of the type of the target. (A “descendant” of a class is the class itself or a direct or indirect heir.) Genericity: To make typing possible in practice, it is necessary to have generic classes, that is to say classes with with the rest of the language. The C++ disaster suffices to show how badly halfhearted solutions can fail. This presentation will discuss the facilities which, in the author’s opinion and experience, are needed to make static typing possible and realistic for an object-oriented language (and whose combination constitutes the Eiffel type system):