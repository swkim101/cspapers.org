Graph data has become a major topic in the database community, in research as well as in industry. ICIJâ€™s Panama Papers investigation which used graph database technology is a recent illustration of this trend [4]. Graph database systems are particularly suitable for querying multi-hop connections between entities, e.g., multi-hop stakeholder relationships between offshore profits and potential tax evaders. Generalized, such queries are referred to as regular path queries (RPQs). RPQs are an important query type on graph database systems [9] and a fundamental part of most graph query languages, such as SPARQL [2] and PGQL [1]. RPQs allow declarative querying of multi-hop connections, i.e., paths in a graph specified by a regular expression. More precisely, an RPQ finds all distinct pairs of vertices in a graph which are connected by at least one path conforming to the given regular expression. Regular expressions of RPQs are formulated based on the set of edge labels (e.g. is-stakeholderof) in the graph. A path conforms to a regular expression, if the concatenation of all edge labels along the path from start to end is in the language accepted by the regular expression. A straightforward way to answer an RPQ on a graph is to convert the regular expression into a deterministic finite automaton (DFA) [3] and use the automaton to steer the traversal of the graph. The state transitions available at the current state in the automaton dictate, based on label equivalence, which edges at a given vertex the graph traversal is allowed to follow. With each traversal step, the automaton does the corresponding transitions: From a start vertex vs, every vertex vf reached by the traversal with the automaton in a final state forms a valid result (vs, vf ) for the query. Two vertices can be connected by multiple valid paths, hence duplicate elimination is necessary and done in each state of the automaton. The traversal can be unidirectional, starting from the initial state of the automaton, or bidirectional, starting additionally in reverse direction from all final states. We focus on the unidirectional traversal. To find all regular paths in a graph, the traversal-based search starts from every vertex. Although all these traversals