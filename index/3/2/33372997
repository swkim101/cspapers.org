EOS {1] is a storage manager that has been prototype at AT&T Bell Laboratories as a vehicle for research into distributed storage architectures for database systems and specially those that integrate programming languages and databases. EOS’S overall goal is to provide fast and transparent access to persistent objects independent of their size and their physical location in a distributed computing environment based on a clientserver architect ure. EOS objects are uninterpreted byte strings which can range in size from a few bytes to gigabytes. Large objects, spanning multiple pages, can be accessed and updated transparently as if they were small objects, or via byte range operations. The byte range operations are important for very large objects – such as digital video and audio – because there may be memory size constraints that would make it impractical to build, retrieve or update the whole object in one big step. EOS files collect related object together and are stored in EOS databases. EOS databases are stored in one or more storage areas (UNIX files or raw disk partitions). Clustering hints for the physical placement of objects in pages, files, databases and areas are also provided. Any EOS object can be named and subsequently retrieved by its name. EOS offers extensible hashing supporting variable size keys and user-defined hash and comparison functions. In addition, other index structures can be built by using page objects objects that expand over the entire available space of a page. EOS employs the multigranularity two version two phase locking protocol, that allows many readers and one writer to access the same item simultaneously. The option to switch to simple 2PL is also available. EOS uses a write-ahead redo-only logging scheme that offers short logs, fast recovery from system failures, and non-blocking checkpoints. Also, configuration files are provided that can be edited by users to customize and tune EOS performance. Finally, the EOS architecture has been designed to be extensible. Users may define hook functions to be executed when certain primitive events occur. This allows controlled access to a number of entry points in the system without compromising modularity.