The domain of early performance analysis and microarchitecture definition is limited largely to a onedimensional perspective of net performance: that of cyclesper-instnrction (CPI). Traceor execution-driven cycle-bycycle simulators [l] are the most common toolsets used at this stage. These are often coded in a systems programming language (e.g. C, C++, PWl or Pascal). They are performance-only models in that the register and memory data values and their state changes are not modelled; only the complex pipeline flow and concurrent instruction processing semantics are simulated. The goal here is to assess CPIcentric performance and bottlenecks to aid early definition, not to ensure functional integrity. Such a simulator, which we call a CPI timer; can be implemented to run at speeds greater than 50,000 instructions per second [21. This is achieved in modelling a future processor with the simulator running on a current generation uniprocessor workstation.