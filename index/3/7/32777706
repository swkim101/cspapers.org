The problem of finding a non-exact occurence of a pattern in a text over some alphabet is a central problem of combinatorial pattern matching and has a variety applications in many areas of computer science. The classic instance of the problem is when the distance between the pattern and a substring of is measured according to the edit distance. That is, the distance between and is equal to the minimum number of insertions, deletions and substitutions of characters that transform into . Despite decades of research, the best algorithm for this problem has running time  if , even if the algorithm is allowed to report approximate answers. This contrasts with the setting when only substitutions are allowed, where nearlinear time approximation algorithms are known. In particular, Karloff [Kar93] showed how to reduce the problem over any to the same problem over , by mapping each symbol from to a sequence of "!# $&%(' random bits. The binary case can be solved in # "!) * time using FFT. Several exact subquadratic-time algorithms exist for general as well (references omitted due to lack of space). In this paper we investigate searching under the edit distance in the following setting. Let be a substring of . We call a ,+/., -match if can be transformed into using at most + insertions or deletions and . substitutions. The key feature in this definition is that the number of insertions and deletions (indels) is separated from the number of substitutions. Since substitutions are “easier” to handle, this allows us to obtain algorithms with better performance than when +102. arbitrary edit operations are allowed. In particular, we show