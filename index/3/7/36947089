Wireless sensor networks have limited resources and tight energy budgets. These constraints make in-network processing a prerequisite for scalable and long-lived applications. However, as sensor networks are embedded in uncontrolled environments, a user often does not know exactly what the sensor data will look like, and so must be able to reprogram sensor network nodes after deployment. Proposals for domain specific languages — still an area of open investigation [1, 3, 4] — present possible programming models for writing these programs. TinySQL queries, for example, declare how nodes should aggregate data as it flows to the root of a collection tree. This wide range of programming abstractions has led to a similarly wide range of supporting runtimes, ranging from in-network query processors [3] to native thread libraries [4] to on-node script interpreters [1]. However, each is a vertically integrated solution, making them all mutually incompatible with each other. Additionally, they all make implementation assumptions or simplifications that lead to unnecessary inefficiencies. Rather than propose a new programming approach to in-network processing, we present a way to implementa programming model’s underlying runtime: using an application-specific virtual machine (ASVM). ASVMs allow users to customize a runtime to the demands of a particular application domain. We have developed Mat é, an architecture for building ASVMs, and demonstrate its use[2]. The components of an ASVM can be separated into two classes: the template, which every ASVM includes, andextensions , the application-specific components that define a particular ASVM. The template includes a scheduler, concurrency manager, and capsule store. The scheduler executes runnable threads in a FIFO roundrobin fashion. The concurrency manager controls what threads are runnable, ensuring race-free and deadlock-free handler execution. The capsule store manages code storage and loading, propagating code capsules and notifying the ASVM when new code arrives. The basic question that arises in such an architecture is defining the boundary between user-level programs — dynamic code— and the retasking system —static code. The set of operations an ASVM