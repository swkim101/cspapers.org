Efficient proof checking The interest in automatic theorem proving, which was very high in the Al community in the late sixties, has decreased. One of the reasons was the impossibility by now of obtaining a theorem prover of wide applicability. In particular "complete" search strategies based on resolution have been heavily criticized. In fact it is felt that the cru cial problem is not to have an efficient prover but to be able to communicate with it and to drive it. It is also felt that efficiency improvements cannot increase significantly the performance. While this skepticism is partially justified in the case of automatic, theorem proving, we think that a careful complexity analysis may help in improving substantially the performance of proof checkers. We agree with Kowalski that logic formal isms are to be considered as programming languages and proof checkers as interpreters. Thus a powerful logic formalism and an efficient proof checker can allow to prove manually theorems whose automatic proof would be otherwise very far from the state of the art. As a step in this direction, in[Boyer, Moore 72] a clever technique has been developed for storing shared structures in resolution-based proof checkers. However, since the standard unification algorithm does not always take advantage of structure sharing, its performance in this setting can be extremely bad. We show in [ Martel.1i,Montana ri 77] a simple example where checking a proof of n steps may require 2 2 operations. Efficient unification Quasi linear and linear algorithms for unifica tion have been recently proposed (see for instance [Martelli, Montanari 76]). The quasi linear algorithm uses counters to discover when a variable is ready to be bound and is particularly appealing in practice, since it is only slightly more complicated than the standard algorithm and needs only the usual, top-down, LISP-like data structures. However, the time spent for initializations might be quite heavy, especially for small cases, and it could be reduced only through a close integration , of the unification algorithm in the whole theorem prover. In [Martelli, Montanari 77] we thus suggest to merge our quasi linear unification algorithm with Boyer and Moore technique. While the simple juxtaposition of the two methods reduces the worst case above to 2 n , we propose in addition to modify them in order to make explicit further sharing and to eliminate non accessible variables. Improving Boyer and Moore technique We suggest â€¦