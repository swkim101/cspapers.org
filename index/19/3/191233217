En esta tesis se estudia el modelo de ejecucion de los procesadores multithreaded especulativos asi como los requisitos necesarios para su implementacion. El modelo de ejecucion se basa en la insercion de instrucciones de spawn dentro del codigo secuencial. De esta manera, la ejecucion de un programa en estos procesadores es similar a cualquier otro hasta que se encuentra con un punto de spawn. Entonces, se crea un nuevo thread especulativo en el punto indicado por la instruccion de spawn y ambos threads se ejecutan en paralelo. Cuanto el thread creador llega al punto inicial del thread especulativo, se ha de verificar si la especulacion ha sido correcta. En ese caso, el contexto del thread no especulativo se gradua y se libera para uso futuro de mas threads especulativos. En caso de que la verificacion no haya sido correcta, se recupera el estado correcto. En este modelo de ejecucion siempre hay un thread no especulativo y puede haber multiples threads especulativos.
Para soportar este modelo de ejecucion, se necesita: i) hardware capaz de crear y gestionar threads especulativo y ii) un mecanismo de particionado para dividir los programas en threads especulativos.
Se han estudiado varias plataformas para gestionar threads de forma concurrente. Por un lado, los procesadores clustered se benefician de menores retardos, menor potencia consumida y una menor complejidad aunque las latencias de comunicacion sean mayores. Por otro lado, las arquitecturas centralizadas se benefician del hecho de compartir recursos y menor latencia de comunicacion, pero la complejidad del hardware es mucho mayor. En cualquier caso, el hardware ha de ser capaz de ejecutar multiples threads simultaneamente con el inconveniente de que algunos valores van a tener que compartirse mientras que otros son copias privadas. Es decir, el procesador debera ser capaz de gestionar multiples versiones de un mismo registro o posicion de memoria para cada uno de los threads que se esten ejecutando.
Ademas, se ha puesto especial enfasis en la gestion de las dependencias de datos entre los threads especulativos ya que tienen un impacto muy importante en el rendimiento del procesador. Encontrar threads independientes es casi imposible en aplicaciones irregulares, por tanto los threads especulativos necesitaran de valores producidos por otros threads especulativos. Se han estudiado dos mecanismos: sincronizar el thread productor y el thread consumidor y predecir los valores dependientes. En el primer caso, se han propuesto mecanismos para pasar el valor tan pronto como ha sido producido del productor al consumidor, especialmente en el caso de valores de memoria. Por otro lado, el segundo modelo es mucho mas atrayente ya que si todos los valores dependientes fueran predichos de forma correcta, los threads pasarian a ejecutarse de forma independiente. Se han evaluado multiples predictores de valores propuestos en la literatura y se ha presentado un nuevo predictor especialmente pensado para este tipo de arquitecturas que es el predictor de incremento. Este predictor usa la informacion de control de los threads especulativos para predecir los valores y los resultados obtenidos son muy prometedores aun con tamanos muy reducidos del predictor.
Finalmente, el particionado de las aplicaciones afecta al rendimiento de este tipo de procesadores. Se han propuesto y evaluado varios esquemas de particionado. Una familia de estos esquemas asigna threads especulativos a construcciones de programa que por si solas proporcionan cierta independencia de control. Politicas de esta familia son aquellas que crean threads especulativos en iteraciones de bucles, continuaciones de bucles y continuaciones de subrutinas. La segunda familia de esquemas de particionado
se ayuda de un analisis basado en profiling para encontrar las parejas de spawn mas idoneas para cada uno de los codigos. De esta manera, aquellas partes del programa que cumplan las mejores caracteristicas se seleccionan para crear threads especulativos. Algunos criterios de seleccion que han sido considerados en esta tesis han sido: la independencia de control, el tamano minimo de los threads, la independencia de datos y su predictabilidad. Los resultados obtenidos por ambas familias han sido muy significativos, aunque el esquema basado en tecnicas de profile mejora los resultados obtenidos por la otra familia.