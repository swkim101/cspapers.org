Consider the following scenario from the not-too-distant future: the CEO of a company is presenting his vision for the next quarter to a small group of co-workers. The CEO trusts everyone in the room, but many in attendance have smartphones and camera-equipped wearable computing devices running third-party apps. The CEO is worried that this third-party software could leak the highly confidential information in his slides and on the whiteboard. This raises the question: how can the CEO prevent apps with camera access from leaking company secrets? First, the CEO must have a way of identifying or marking visual secrets. Markings should be: (1) easy to create by hand and with digital tools, and (2) easy and efficient to recognize by software. Marking visual secrets by placing QR-codes or badges near them makes real-time recognition difficult due to scaling problems (particularly at far distances). Moreover, precisely encoding a two-dimensional region surrounding a visual secret in a QR-code or badge would be too awkward and slow for users. Finally, general-purpose object recognition is too slow and consumes too much energy. In this demo, we present PrivateEye, a system that prevents visual secrets from inadvertently leaking. PrivateEye consists of two pieces: (1) a specification for marking a two-dimensional space as secret, and (2) software on a recording device for recognizing markings and obscuring visual secrets in real-time. Figure 1(a) and 2(a) show examples of how PrivateEye users can define a region containing visual secrets by combining solid and dotted lines. Depending on the medium, users can define secret regions by hand (e.g., on a whiteboard) or use digital tools (e.g., within a presentation). PrivateEye is based on the principle that preventing leaks requires visual information to be withheld from third-party apps until the system can be confident that it is safe to reveal. As a result, PrivateEye works in three phases. Phase 1 requires the camera view to stabilize. During this phase, PrivateEye completely blurs the camera view so that apps cannot infer secret information from an image capture. Once the camera view stabilizes, PrivateEye enters Phase 2, in which the system detects all the rectangles in the camera view. At this point, all the detected rectangles appear blocked to the user (Figure 1(b) and 2(b)). PrivateEye then moves on to Phase 3. In this phase, the system searches each blocked rectangle for secret markings (i.e., dotted rectangles). PrivateEye can safely reveal the content of rectangles without secret markings to an app; however, the system must continue to block any rectangles containing secret markings. If PrivateEye detects that the camera view has changed, then it must return to Phase 1. During the demo, PrivateEye will be running on Google Nexus 4 and Google Glass. We plan to invite the audience to use one of these devices and view some of the objects already marked secret. We will also let them draw the markers around some text on a whiteboard. This will help the audience to understand the usability and effectiveness of PrivateEye.