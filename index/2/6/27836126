We describe an interpreter for pLucid, a member of the Lucid family of functional dataflow languages. In appearance, pLucid is similar to Landin's Iswim, exept that individual variables and expressions denote streams (infinite sequences of data items), and function variables denote filters (stream-to-stream transformations). The actual data objects in pLucid (the components of streams) are those of POP2: numbers, strings, words, and lists. The 'inner syntax' (infix operations, conventions for denoting constants) are those of POP2 as well.The interpreter (which was written in C) is eductive: it uses a tagged demand-driven scheme. Demands for values in the output stream generate demands for values of other variables internal to the program. These demands, and the values returned in response, are tagged according to "time" (sequence index) and place (node in the tree of function calls). Once computed, values are stored in an associative memory (the "warehouse") in case they are demanded again later in the computation. The warehouse is periodically cleaned out using a heuristic called the "retirement plan". The heuristic is not perfect, but does not have to be: in an eductive computation, the program is not altered as in reduction. If discarded values are needed again, they can be recomputed.The pLucid interpreter performs extensive runtime checks and error messages quote the source line containing the offended operator. A special end-of-data object permits a very simple treatment of finite (terminating) input and output. Of special interest is its interface to UNIX, which allows any system command to be used as a filter inside a pLucid program.The interpreter performs well enough for nontrivial programs to be developed and tested. These include (simple versions of) a text formatter, a distributed airline reservation system, and a full screen editor.