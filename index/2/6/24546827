Ever since formal verification was first proposed in the late sixties, the idea of being able to definitively determine if a program meets its specifications has been an appealing, but elusive, goal. Although verification systems based on theorem proving have improved considerably over the years, they are still inherently undecidable and require significant guidance from mathematically astute users. The human effort required for formal verification is so significant that it is usually only applied to the most critical software components.
Alternative approaches to theorem proving based verification have also been under development for some time. These approaches usually restrict the problem domain in some way, such as focusing on hardware descriptions, communication protocols, or a limited specification language. These restrictions allow the problem to be solved by using reasoning algorithms that are guaranteed to terminate and by representing the problem with a finite state model, and thus these approaches have been called finite state verification. Systems based on these approaches are starting to be effectively applied to interesting software systems and there is increasing optimism that such approaches will become widely applicable.
In this presentation, I will overview some of the different approaches to finite state verification. In particular I will describe symbolic model checking, integer necessary constraints, and incremental data flow analysis approaches. The strengths and weaknesses of these approaches will be described. In addition, I will outline the major challenges that must be addressed before finite state verification will become a common tool for the typical well-trained software engineer.