The question of the appropriate role of program correcmess proofs in the undergraduate curriculum is current and even controversial ([2] and responses). The issue is somewhat analogous to the question of when to introduce & limit proofs in the mathematics curriculum. For many of us who came to computer science via mathematics there was a major difference, however. We came to the calculus issue with years of coursework in real analysis and abstract mathematics. We had a basis for our opkions, a confidence in our experimentation, and an assurance that we could pinpoint precisely the source of fuzzy thinking on the part of our students-. We could get formal and rigorous when we deemed it appropriate. When I began teaching programming, it was not with the same degree of confidence or competence. I was comfortable with syntax, structured programming, stepwise refinement, modularity and testing. However, I had no tools for formal examination or explanation of code. The best I could do to convince students that a loop “worked” was to step through a few iterations, hoping that the pattern of execution would “become obvious”. Fortumtely, we had David Gries and others to chide us, present workshops for us, and write books ([3]) for us. I was especially fortunate to take a short course from David in the IFRICS program at Clarkson University. This helped. I could now deal with weakest precondition semantics for assignment statements (both for simple variables and arrays), conditional statements, and compound statements. Loop invariants provided a sufficient tool for working with loop statements. Byproducts of this approach were clarity of specifications and documentation, tools for program development, and a methodology for program or algorithm presentation. This goes along way toward enabling us to get formal and