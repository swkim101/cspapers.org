Nokia is an international telecommunications group with headquarters in Helsinki, Finland. The group produces a range of telecommunications equipment for cellular and fued networks, from switches and transmission equipment to cellular phones. Developing software for these products presents a number of difficult problems partly due to complex and often conflicting requirements that include: achieving function reliability without replicating parts and thus increasing the costs, providing feature variation in products while achieving reuse, doing parallel development by geographically distributed teams while controlling performance and integration of products In this talk we present our experiences of addressing these problems in several Nokia products with special focus on Synfonet Synchronous Digital Hierarchy network transport system. These products represent a class of configurable, distributed, embedded, real-time, dependable systems with several optional levels of software and hardware fault tolerance and function protection. For example Synfonet supports live removal and insertion of cards while preserving configuration data and enabling hot-restart of re-inserted cards. This capability is based on a reliable storage system that transparently distributes data over several cards. The system maintains at all times a number of copies necessary to preserve the state while one or several cards may be removed, and to resolve possible conflicts due, for example, to stale or otherwise incorrect configuration on newly inserted cards. Constraints of specific operating system, storage media, and other systemspecific characteristics could not be satisfied by any COTS products available at the time of system design. Therefor the reliable storage system and a number of other generic components were developed in house. To cover the costs of developing such complex software components we had to design for reuse of these components in several products. Permission to make digit&hard copies of all or pat ofthis material for personal or classroom use is granted without fee provided that the copies are not made or distributed for profit or commercial ndvnntage, the copyright notice, the title of the publication and its date appear, and notice is given that copyrigl~t is by permission of the ACM, Inc. To copy othenvise, to republish, to post on servers or to redistribute to lists, requires specific permission and/or fee ICSE 97 Boston MA USA Copyright 1997 ACM O-89791-914-9/97/05 ..$3.50 Rather than targeting component-based reuse relying on very general and flexible design and extensive parametrization of the components we approached the problem from the other end. We designed an architecture for a family of transport networks products and made the general components reusable by being an integral part of this specific software architecture. Designing and managing software architecture for a product family presents a number of problems that can be avoided. Some of the ideas we present in the talk originated from ARES a cooperative European research project (ESPRIT). In ARES Nokia is leading a consortium of partners from ABB, London Imperial College, Philips, Polytechnical University of Madrid, and Technical University of Vienna, together evaluating architectural techniques on existing families of embedded software . There is often a temptation to adopt a single view on the partition of software as the architecture, and have a uniform structure exist in different component domains, This however may lead to an inferior design. An example of the kind involved a system that was partitioned into a set of distributed processes. The partition was motivated by considerations of required parallelism, availability, and fault tolerance. This partition was subsequently used for allocation of additional functionality. That affected resource requirements and timing characteristics, violating the original design. As a cure non real time functionality was allocated to new components. However since the architecture of software was identified with its process structure these components became independent processes. As a result components had complex interfaces and performance was compromised. Our current understanding suggests that sofhvare architecting must start with specific architectural concerns, specify the partition in different component domains along with a scheme for integration and coordination of the parts, and explain how this specific partition and the corresponding integration of the sofhvare address the specified architectural concerns. Examples of architectural concerns may include timeliness, capacity, availability, effective division of work, conformance to standards, utilization of existing parts, or controlled propagation of change. Different partitions may exist in different component domains such as files, modules, processes, threads, processors and other resources.