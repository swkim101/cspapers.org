Richard E. Pattis Department of Computer Science University of Washington Seattle, WA 98195 I n t r o d u c t i o n In this paper I discuss two forms of abstract ion--data abstraction and control abstraction--and some connections between them. I will use the Pascal language to illustrate each form of abstraction, because of its current popularity for teaching introductory programming courses in computer science. I believe that students should learn these forms of abstraction during such a first programming course. Although the material in this paper is not new, it has yet to find its way into mainstream introductory programming courses, possibly because of a lack of coherent exposition at the right level. The first part of this paper (Sections 1.1-I.8) discusses data abstraction, using arrays for its central example: it differentiates between arrays that are built-in to Pascal and a more general array abstraction. We will see how to build a general array abstraction by using a simple combination of Pascal's records and built-in arrays. We will also examine the low-level array operations Get and Put, and see how they can be combined with the general array abstraction to implement exotic forms of arrays. Finally, we wilt discuss how the consistent use of these abstractions can be help simplify our programming tasks by making program construction more uniform (at a high level), flexible (at a low level), and less prone to error overall. The second part of this paper (Sections II.l-II.5) discusses generators, a control abstraction that nicely generalizes FOR loops. Generators allow us to explicitly represent and manipulate the state of a FOR-loop-like control structure. We will first construct a simple generator that mimics a FOR loop, and then extend it to filter out unwanted indexes automatically. Finally, we will combine generators and the general array abstractions examined in the first part of this paper to discuss how to write simple code that traverses arrays. Combining generators with abstract arrays also allows us to write more simple and reliable code, by letting us hide many details inside the generators and array abstractions themselves. For a further examination of these topics, see [Liskov]. 1.1 D a t a A b s t r a c t i o n : P r i m i t i v e A r r a y s and T h e i r S h o r t c o m i n g s The Pascal programming language provides a primitive built-in definition and implementation of arrays. In the functional terminology used to model arrays, Pascal allows programmers to declare array types using any ordinal types for the domain (indexes) and any type for the range (elements). Given a domain index within the declared lower and upper bounds, each matching range element can be accessed--retrieved or updated-in O(1) time; Pascal ensures that each access is within the declared bounds of the array, otherwise it signals the occurrence of an execution error. In many programming applications, arrays are contiguous: either they are completely filled, with each domain index between the lower and upper bound having a matching range element, or the filled portion of the array (possibly empty) lies between two legal domain indexes. Most often the lower of these indexes is equal to the declared lower bound of the array, whose value is most often 0 or 1. We can store simple lists in arrays by this method of contiguous storage. But this primitive built-in definition and implementation or arrays is inadequate for modeling many programming applications: programmers often need to retrieve and update other kinds of information about the arrays that they are using. In the case of filled arrays, a programmer must know what are the declared lower and upper bounds of the array (e.g., looping through the array); well written programs will declare for each array type two related constants containing these values. For unfilled arrays, a programmer needs to know the current size of (or number of elements stored in) an array; well written programs will declare for each array variable an extra, related variable that contains this information. When processing arrays, some operations may fail: filling an array with values read from a file may fail for a variety of reasons (e.g., the number of values in the file exceeds the number of values storable in the array or an illegal value is read); an error indicator for each array can be stored in another related variable, or the operation can be converted into a function that returns an error code. This method of representing arrays and their related attributes complicates our programs tremendously. To represent an array--and all its related at tr ibutes--we need to distribute the information into the array variable itself and into a host of related constants and variables, each needing a unique name. This appro£ch requires a programmer to remember too many connections Permission to copy without fee all or part of this material is granted provided that the copies are not made or distributed for direct commercial advantage, the ACM copyright notice and the title of the publication and its date appear, and notice is given that copying is by permission of the Association for Computing Machinery. To copy otherwise, or to republish, requires a fee and/ or specific permission. ©1987 ACM 0-89791-217-9/87/0002/0044 75¢