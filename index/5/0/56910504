There will be a large population of users who will not want to design programs as we know them but will simply want to add a new piece of software to their library as they would a book, a phonograph record or a game. Can we design such modular, extensible microsystems with a simple transparent user interface? There will be a population of users who want to design and use programs on microprocessors without ever going to a larger shared resource. What languages and programming systems do we forsee to enforce structure in program design and provide tools sometimes needed for optimization? There will be a population of users who need to write programs that behave well and whose systems interface to foreign devices with real time constraints. What supported methodology can we offer, given that we do not do this very well with larger systems? There will be a population of users who want to solve computer limited problems on highly concurrent systems making use of large ensembles of microprocessors. Can we provide languages and software that make such cooperative computing meaningful? Are there any ways in which we can make use of the highly amortized software investments made to satisfy the needs of mass users? The panel participants will make a short position statement and then questions from the panel members and the audience will be considered.