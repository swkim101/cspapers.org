Software transactional memory (STM) can lead to scalable implementations of concurrent programs, as the relative performance of an application increases with the number of threads that support it. However, the absolute performance is typically impaired by the overheads of transaction management and instrumented accesses to shared memory. This often leads a STMbased program with a low thread count to perform worse than a sequential, non-instrumented version of the same application. We propose FastLane, a new STM system that bridges the performance gap between sequential execution and classical STM algorithms when running on few cores (see Figure 1). FastLane seeks to reduce instrumentation costs and thus performance degradation in its target operation range. We introduce a family of algorithms that differentiate between two types of threads: One thread (the master) is allowed to commit transactions without aborting, thus with minimal instrumentation and management costs and at nearly sequential speed, while other threads (the helpers) execute speculatively. Helpers typically run slower than STM threads, as they should contribute to the application progress without impairing on the performance of the master (in particular, helpers never cause aborts for the masterâ€™s transactions) in addition to performing the extra bookkeeping associated with memory accesses. FastLane is implemented within a state-of-the-art STM runtime and compiler. Multiple code paths are generated for execution: sequential on a single core, FastLane (master and helper) for few cores, and STM for many cores. Applications can dynamically select a variant at runtime, depending on the number of cores available for execution. Preliminary evaluation results indicate that our approach provides promising performance at low thread counts: FastLane almost systematically wins over a classical STM in the 2-4 threads range, and often performs better than sequential execu-