We present ROSE, a high-fidelity, pluggable framework for binary analysis. ROSE has the unique capability of executing a program concretely or abstractly, starting from any offset. Thus, ROSE can analyze program fragments or functions in third-party binaries. The challenge inherent to starting from any offset is handling the initial lack of state. To overcome this challenge, ROSE accurately models each non-floating-point x86 instruction and how it operates on the heap, stack, and register file. This model and ROSE’s support for system calls guarantee that no external, unanalyzable functions exist to limit or disrupt ROSE’s analysis. ROSE supports execution over any abstract domain. Finally, ROSE integrates a disassembler and simulator: on behalf of the disassembler, the simulator resolves indirect jumps; in turn, the disassembler informs the simulator where valid instructions start. This synergism improves the state-of-the-art in detecting indirect jumps and functions. To test ROSE, we compared its concrete interpretation against native execution, instruction by instruction, for programs in POSIX.12008. For system calls, including threading, ROSE marshals a program’s interpreted state to and from native, concrete state; this mechanism passes the Linux Test Project. ROSE is easy to use: To incorporate a new abstract domain, one need only define a small set of functions. ROSE can simultaneously support multiple abstract domains and allow the user to determine which function it currently interprets. We use case studies to demonstrate its extensive feature set. ROSE is licensed under the MIT license and available for download at <anonymized url>.