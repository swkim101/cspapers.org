The IBM RT PC implements the necessary features of 801 storage architecture. The upper 4 bits of a 32-bit short address select one of 16 segment registers. A 12-bit segment id from the register replaces the 4 bits to form a 40-bit long virtual address. This creates a single large space of 4096 256M-byte segments. Only the supervisor may load segment registers and may therefore control access to and sharing of segments. A long virtual address is translated to real by an inverted page table, in which each entry contains the virtual page address currently allocated to a real page. Hardware searches the table using chained hashing. If a given virtual address is found in a table entry, the index of that entry is the desired real page address. Table size is related only to real storage size rather than to virtual size as with conventional segment and page tables. The inverted page table includes a transaction locking mechanism. Each entry contains bits to represent read and write locks, for 128-byte lines within the page, granted to the transaction id also in the entry. Lock fault interrupt occurs when storage access by the current transaction (id in a register) is not permitted by locks and id in a table entry. Page protection bits may instead be used when transaction locking is not required.
 A CPR transaction is all the storage actions by a process on a set of file segments, performed between two calls to commit for that set of segments, including actions of the supervisor in directory segments when files are created, renamed, etc. File open options influence transaction processing. When open options specify file sharing and implicit functions of serialization and atomic commit, we call the file segments database storage. Transaction locking hardware is used. Lock fault interrupts invoke the storage manager to grant locks and later, when a transaction commits, the storage manager writes log records of changed storage. Strong transaction properties are achieved, without explicit calls from programs which access storage and independently of superimposed data organization or access pattern. A language-based approach to invoking transaction functions seems to be more explicit and restrictive.
PL.8 is a PL/I dialect for systems programming and the PL.8 compiler is part of the 801 project. To simplify file programming, a persistent storage class (i.e. storage in a file segment) and a refp type (capability to a file segment id) were added to PL.8. Persistent storage may be used with any type, including arrays of structures and based structures in areas (appropriate for records, indices, etc.). Semantics of computation with persistent variables depend only on type and so are the same as computation in working storage classes automatic, static, and controlled (heap). Computation with large aggregates over multiple file segments is possible, exceeding 32-bit addressing.
 Database storage is a new way to implement certain storage management functions in an operating system, built on and similar in spirit to virtual storage. Both are very general, transparent, and rather monolithic approaches to storage management, one for storage hierarchy, the other for storage concurrency and recovery. We believe that database storage will perform well for a wide range of applications and that the simplicity it offers is too attractive to dismiss. As in the early days of virtual storage, the challenge is to understand and exploit its characteristics.