AspectJ[4] allows Java programmers to divide program code into separate pieces, each of that describes a different aspect. These pieces are merged at join points by the AspectJ compiler into a single regular program. The degree of separation of concerns enabled AspectJ obviously depends on what join points are provided. In fact, the specifications of AspectJ with respect to join points have been evolved release by release. While some new kinds of join point have been added, others have been removed due to lack of applications. The designers of AspectJ seem to try to find a good trade-off point between usefulness and simplicity of the language design. This fact is also observed in other aspect-oriented languages such as Hyper/J[5]. However, join points are not brand new concepts unique to aspect orientation. For example, class inheritance can be considered as a framework providing a join point since it enables to borrow and reuse the implementation of a method from a super class. Another framework providing a join point is found in reflective languages. Typical reflective languages [1, 7] provide metaobjects, which allow programmers to intercept method invocation and alter the behavior of the invocation at runtime. Although this is just a mechanism, the programmers can use it for implementing a sort of join point; the metaobject may call a method on another object to be automatically executed before the intercepted method.