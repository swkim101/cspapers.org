WepresentzIO,atransparentzero-copyIOmechanismforun-modifiedIO-intensiveapplications.zIOtracksIOdatathroughtheapplication,eliminatingcopiesthatareunnecessarywhilemaintainingdataconsistency.Applicationsoftenmodifyonlyapartofthedatatheypro-cess.zIOleveragesthisinsightandinterposesonIOstackandstandardlibrarymemorycopycallstotrackIOdataandeliminateunnecessarycopies.Instead,intermediatedatalo-cationsareunmapped,allowingzIOtointerceptandresolve any access via page faults to maintain data consistency. To avoid harming application performance in situations where data tracking overhead is high, zIO’s tracking policy decides on a per IO basis when to eliminate copies. Further, we demonstrate how to use zIO to achieve optimistic network receiver persistence for applications storing data from the network in non-volatile memory (NVM). By mapping socket receive buffers in NVM and leveraging kernel-bypass IO, we can rely on zIO to transparently eliminate all copies from the network, through the application, to storage. We implement zIO as a user-space library. On top of kernel IO stacks, zIO eliminates application-level IO copies. We also integrate zIO with kernel-bypass IO stacks, where it can additionally eliminate copies incurred by the IO stack APIs and enable optimistic network receiver persistence. We evaluate zIO with IO-intensive applications, such as Redis, Icecast, and MongoDB.zIOimprovesapplicationthroughputbyupto1.8 × with Linux and by up to 2.5 × with kernel-bypass IO stacks and optimistic network receiver persistence. Compared to common uses of zero-copy IO stack APIs, such as memory mapped files, zIO can improve performance by up to 17% due to reduced TLB shootdown overhead.