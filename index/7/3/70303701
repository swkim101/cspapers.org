Mobile computing has grown drastically over the past decade. There are already more than 2 billion mobile devices in circulation worldwide [1] and the number of mobile subscribers is expected to cross the 6 billion mark in coming years [2]. A high-quality user experience and longer battery life are the key challenges in building competent mobile devices including smartphone, tablets, and other handheld devices. To meet the heavy processing demands of high-quality user experience, these devices generally deploy out-of-order (OoO) processing cores. However, the high energy requirements of OoO execution directly limit the battery life. This work investigates a minimum out-of-order core that approaches the performance of full OoO execution, however, only at a fraction of its energy cost. In pursuit of performance, an OoO core exploits an applicationâ€™s inherent instruction level parallelism (ILP) by executing independent instructions out of the program order. However, it employs a number of large, complex, and power hungry hardware structures such as instruction queue (IQ), physical register files (PRF), and load/store queues (LSQ) etc. to expose the ILP. Instruction queue, which is typically implemented as a content addressable memory (CAM), is arguably the most complex and power hungry structure of an OoO core. It comprises a complex web of wires and combinational circuits to broadcast the results (or physical register ids) to make waiting instructions ready for execution and select among ready instructions based on set priorities. Furthermore, to a first order, the complexity and power consumption of IQ increases quadratically with issue width and linearly with the number of entries. In this work, we study the behaviour of SPECcpu2006 workloads and discover that not all instructions need to pass through these complex OoO structures to expose ILP. In particular, as shown in Figure 1, we found that in a typcial mobile core, with 128 ROB entries and 4-wide issue, about 28% of the instructions are ready for execution when they are dispatched to the IQ, we call these Ready at Dispatch (R@D) instructions. Also, a further 15% of instructions become ready within 2 cycles after dispatch, called Almost Ready at Dispatch AR@D instructions. Based on these results, we make a critical observation that a complex IQ brings little or no ILP benefits for these instructions as they can execute in program order with minimal stalls. Our second key observation is that the values/results passed among R@D and/or AR@D instructions em sDTD bzip2 dalII gobm k rom cs hm m er libantum m cf m ilc am d om ntpp pvray seng splex rf xancbm k VG 0 10 20 30 40 50 60 70 80 90 100