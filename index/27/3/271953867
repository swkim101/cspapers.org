Conventional cache moves a block of contiguous data and allocates space for them together, which works well for applications with good spatial locality. However, many applications have poor spatial locality. In the multi-core and multi-program system, contentions at each level of the memory hierarchy can cause early cache block eviction and reduce the benefit of locality. When running these applications, conventional cache suffers from poor effective cache capacity and high data movement overhead. Storing data that will not be used before eviction reduces the effective capacity and degrades performance. In addition, data over-fetching from main memory to cache wastes bandwidth and energy. Fine-grained caches [1], which use small cache block size and only fetch useful data to cache, have been proposed to improve effective capacity. However, the size of the metadata needs to be increased to support data identification, state tracking, and replacement at a smaller data granularity. To reduce the metadata overhead, one approach is to share the common tag bits among multiple fine-grained blocks within one merged block [2] . However, in order to share the common tag bits, data that can be stored in the same merged block has constraints. A merged block may not be completely filled and therefore can waste cache space.