The benefits of strong typing to disciplined programming, tocompile-time error detection and to program verification are wellknown. Strong typing is especially natural for functional(applicative) languages, in which function application is thecentral construct, and type matching is therefore a principalprogram correctness check. In practice, however, assigning a typeto each and every expression in a functional program can beprohibitively cumbersome. As expressions are compounded, the taskof assigning a type to each expression and subexpression becomespractically impossible, even more so because the type-expressionsthemselves grow longer. It becomes imperative therefore to designfriendly programming environments that permit the user type-freeprogramming, but that generate fully typed programs in which thetypes of all expressions are inferred by the system from theprogram. For interactive functional programming environments of thekind implemented for the Edinburgh functional programming languageML, a type-inference system is an invaluable tool for on-lineparse-time error detection and debugging.
The issue of type inference leads naturally totype-schemes. If all one has of a functional program is adefinition statement such as f(x)=3, then all one cansay of the type of f is that it must be of the form’Ñ¨int, i.e. --- an instance of the type schemet ¨ int, where t is a type variable. As more ofthe program appears, say x(true)=z, t may berestricted, to bool¨s. We are thereforeinterested in type-schemes, using type parameters(free type variables). All one needs then to obtain a rudimentaryform of generic procedures is a device for type instantiation. Thisfunction is fulfilled in ML by the construct let. Other methods aredescribed in Ü4 below.
During the process of inferring a type for a given program, onewould like at each step to find a most general (so-calledprincipal) type scheme for each subexpression, so that typesto be assigned to variables and subexpressions in the sequel may beassumed to be instances of those assigned earlier. The notion ofprincipal type was introduced by Curry and Feys [CF] forCombinatory Logic, and Hindley [Hin] showed that the principal typeexists for any Combinatory Logic expression and that it can befound using J.A. Robinson's Unification algorithm [Rob].The seminalpaper on type-inference for functional programs is Milner's [Mil],where an algorithm W is defined for inferring a type for any MLprogram (without recursively defined types). More recently, Damasand Milner [DM] defined a simple formal calculus of type inference,with respect to which W is proved complete.
In this paper we study several aspects of type inference forpolymorphic type disciplines. First, we deal with type inferencefor parametric type systems, that is --- type systems that includesimple types defied over constant types and type variables. Werecast Milner's algorithm W in a general "algebraic" form, whichapplies to a variety of generic type disciplines (Ü2). InÜ3 we present an alternative algorithm V for type inference,fundamentally different from W, which easily accommodates typecoercion and overloading, allows efficient local updates to theuser program, and is more efficient than W for implementations thatallow concurrency.
In Ü4 we briefly describe four polymorphic disciplines:type abstraction, type quantification, type conjunction(intersection) and the ML construct let.
In Ü5 type inference for the abstraction and quantificationdisciplines is discussed. We point out that the two disciplines arecombinatorially isomorphic, and we outline a type inferencealgorithm for them.
Ü6 is devoted to type inference for the conjunctivediscipline. We mention some limitations to type inference here, inparticular --- the fact that the set of typable expressions is noteffectively decidable. Moreover, there is no feasible algorithmthat would type expressions even when these are given with aquantificational typing. This kind of non-effectiveness motivatesour considering a restriction to types where type conjunction ispermitted only at low levels of functionality. Here the level offunctionality of a function (or procedure) is recursively definedas one plus the greatest level of functionality of its arguments.This gives rise to a hierarchy on polymorphic types, a notion thatis equally natural for the type abstraction and type quantificationdisciplines. We show that our algorithm V (of Ü3) can benaturally extended to the restriction of the conjunctive disciplineto types of rank 2 in the hierarchy, and we outline an argumentshowing that already for a low rank, seemingly 3, type inference isnot effectively decidable.
In Ü7 we discuss the ML construct let in light of ourprevious results. We point out that the polymorphic discipline ofML is isomorphic to the restriction to rank 2 of each one of theother disciplines. This gives weight to the particular choice ofpolymorphism in ML, and to the completeness of Milner's algorithm Wfor that choice. At the same time, the equivalence suggests moreflexible representations of this discipline (namely --- either theconjunctive or the quantificational disciplines restricted to rank2) in which the anomaly in ML, of legal expressions withwell-formed illegal subexpressions, is avoided.