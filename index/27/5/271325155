Rapid embedded device proliferation is creating new targets and opportunities for adversaries. However, the complex interactions between firmware and hardware pose challenges to applying automated testing, such as fuzzing. State-of-the-art methods re-host firmware in emulators and facilitate complex interactions with hardware by provisioning for inputs from a diversity of methods (such as interrupts) from a plethora of devices (such as modems). We recognize a significant disconnect between how a fuzzer generates inputs (as a monolithic file) and how the inputs are consumed during re-hosted execution (as a stream, in slices, per peripheral). We demonstrate the disconnect to significantly impact a fuzzer’s effectiveness at discovering inputs that explore deeper code and bugs. We rethink the input generation process for fuzzing mono-lithic firmware and propose a new approach— multi-stream input generation and representation ; inputs are now a collection of independent streams, one for each peripheral. We demonstrate the versatility and effectiveness of our approach by implementing: i) stream specific mutation strategies; ii) efficient methods for generating useful values for peripherals; iii) enhancing the use of information learned during fuzzing; and iv) improving a fuzzer’s ability to handle roadblocks. We design and build a new fuzzer, M ULTI F UZZ , for testing monolithic firmware and evaluate our approach on synthetic and real-world targets. M ULTI F UZZ passes all 66 unit tests from a benchmark consisting of 46 synthetic binaries targeting a diverse set of microcontrollers. On an evaluation with 23 real-world firmware targets, M ULTI F UZZ outperforms the state-of-the-art fuzzers Fuzzware and Ember-IO. M ULTI F