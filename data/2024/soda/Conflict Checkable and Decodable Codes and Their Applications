Let C be an error-correcting code over a large alphabet q of block length n, and assume that, a possibly corrupted, codeword c is distributively stored among n servers where the ith entry is being held by the ith server. Suppose that every pair of servers publicly announce whether the corresponding coordinates are “consistent” with some legal codeword or “conflicted”. What type of information about c can be inferred from this consistency graph? Can we check whether errors occurred and if so, can we find the error locations and effectively decode? We initiate the study of conflict-checkable and conflict-decodable codes and prove the following main results: (1) (Almost-MDS conflict-checkable codes:) For every distance d ≤ n, there exists a code that supports conflict-based error-detection whose dimension k almost achieves the singleton bound, i.e., k ≥ n − d + 0.99. Interestingly, the code is non-linear, and we give some evidence that suggests that this is inherent. Combinatorially, this yields an n-partite graph over [q] that contains q cliques of size n whose pair-wise intersection is at most n − d ≤ k − 0.99 vertices, generalizing a construction of Alon (Random Struct. Algorithms, ’02) that achieves a similar result for the special case of triangles (n = 3). (2) (Conflict Decodable Codes below half-distance:) For every distance d ≤ n there exists a linear code that supports conflict-based error-decoding up to half of the distance. The code’s dimension k “half-meets” the singleton bound, i.e., k = (n − d + 2)/2, and we prove that this bound is tight for a natural class of such codes. The construction is based on symmetric bivariate polynomials and is rooted in the literature on verifiable secret sharing (Ben-Or, Goldwasser and Wigderson, STOC ’88; Cramer, Damgård, and Maurer, EUROCRYPT ’00). (3) (Robust Conflict Decodable Codes:) We show that the above construction also satisfies a non-trivial notion of robust decoding/detection even when the number of errors is unbounded and up to d/2 of the servers are Byzantine and may lie about their conflicts. The resulting conflict-decoder runs in exponential time in this case, and we present an alternative construction that achieves quasipolynomial complexity at the expense of degrading the dimension to k = (n − d + 3)/3. Our construction is based on trilinear polynomials, and the algorithmic result follows by showing that the induced conflict graph is structured enough to allow efficient recovery of a maximal vertex cover. As an application of the last result, we present the first polynomial-time statistical tworound Verifiable Secret Sharing (resp., three-round general MPC protocol) that remains secure in the presence of an active adversary that corrupts up to t < n/3.001 of the parties. We can *Tel-Aviv University, Israel bennyap@post.tau.ac.il, elirn.chalon@gmail.com.